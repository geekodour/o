<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<link rel="icon" type="image/gif" href="favicon.gif"/>
<link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png" />
<link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png" />
<title>Computer Algebra I: Mathematica, SymPy, Sage, Maxima - Hyperpolyglot</title>
<style type="text/css" id="internal-style">
@import url(hyperpolyglot.css);
</style>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<meta http-equiv="content-language" content="en"/>
</head>
<body>
<div id="container-wrap-wrap">
  <div id="container-wrap">
    <div id="container">
      <div id="header">
        <h1><a href="index.html"><span>Hyperpolyglot</span></a></h1>
      </div>
      <div id="content-wrap">
        <div id="main-content">
<div id="page-title">
                            Computer Algebra I: Mathematica, SymPy, Sage, Maxima
                        </div>
<div id="page-content">
                        

<p><em>a side-by-side reference sheet</em></p>
<p><strong><a href="computer-algebra">sheet one:</a></strong> <a href="computer-algebra#grammar-invocation">grammar and invocation</a> | <a href="computer-algebra#var-expr">variables and expressions</a> | <a href="computer-algebra#arithmetic-logic">arithmetic and logic</a> | <a href="computer-algebra#strings">strings</a> | <a href="computer-algebra#arrays">arrays</a> | <a href="computer-algebra#sets">sets</a> | <a href="computer-algebra#arith-seq">arithmetic sequences</a> | <a href="computer-algebra#dictionaries">dictionaries</a> | <a href="computer-algebra#functions">functions</a> | <a href="computer-algebra#execution-control">execution control</a> | <a href="computer-algebra#exceptions">exceptions</a> | <a href="computer-algebra#streams">streams</a> | <a href="computer-algebra#files">files</a> | <a href="computer-algebra#directories">directories</a> | <a href="computer-algebra#libraries-namespaces">libraries and namespaces</a> | <a href="computer-algebra#reflection">reflection</a></p>
<p><strong>sheet two:</strong> <a href="computer-algebra2#symbolic-expr">symbolic expressions</a> | <a href="computer-algebra2#calculus">calculus</a> | <a href="computer-algebra2#equations-unknowns">equations and unknowns</a> | <a href="computer-algebra2#optimization">optimization</a> | <a href="computer-algebra2#vectors">vectors</a> | <a href="computer-algebra2#matrices">matrices</a> | <a href="computer-algebra2#combinatorics">combinatorics</a> | <a href="computer-algebra2#number-theory">number theory</a> | <a href="computer-algebra2#polynomials">polynomials</a> | <a href="computer-algebra2#trigonometry">trigonometry</a> | <a href="computer-algebra2#special-functions">special functions</a> | <a href="computer-algebra2#permutations">permutations</a> | <a href="computer-algebra2#descriptive-statistics">descriptive statistics</a> | <a href="computer-algebra2#distributions">distributions</a> | <a href="computer-algebra2#statistical-tests">statistical tests</a></p>
<p><a href="computer-algebra2#bar-charts">bar charts</a> | <a href="computer-algebra2#scatter-plots">scatter plots</a> | <a href="computer-algebra2#line-charts">line charts</a> | <a href="computer-algebra2#surface-charts">surface charts</a> | <a href="computer-algebra2#chart-options">chart options</a></p>
<table class="wiki-content-table">
<tr>
<th></th>
<th><a href="computer-algebra2#mathematica">mathematica</a></th>
<th><a href="computer-algebra2#sympy">sympy</a></th>
<th><a href="computer-algebra2#sage">sage</a></th>
<th><a href="computer-algebra2#maxima">maxima</a></th>
</tr>
<tr>
<th colspan="5"><a name="symbolic-expr" id="symbolic-expr"></a><a href="computer-algebra2#symbolic-expr-note">symbolic expressions</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="symbolic-expr-literal" id="symbolic-expr-literal"></a><a href="computer-algebra2#symbolic-expr-literal-note">literal</a></td>
<td>expr = 1 + x + x^2</td>
<td>x = symbols('x')<br />
<br />
expr = 1 + x + x^2</td>
<td>expr = 1 + x + x^2</td>
<td>expr = 1 + x + x^2;</td>
</tr>
<tr>
<td><a name="prevent-simplification" id="prevent-simplification"></a><a href="computer-algebra2#prevent-simplification-note">prevent simplification</a></td>
<td>HoldForm[x + x]<br />
x + x <span style="white-space: pre-wrap;">//</span> HoldForm</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="symbolic-expr-var-update" id="symbolic-expr-var-update"></a><a href="computer-algebra2#symbolic-expr-var-update-note">variable update</a></td>
<td>expr = 1 + x<br />
x = 3<br />
<span style="color: gray">(* 4: *)</span><br />
expr</td>
<td>x = symbols('x')<br />
expr = 1 + x<br />
x = 3<br />
<span style="color: gray"># 1 + x:</span><br />
expr</td>
<td>expr = 1 + x<br />
x = 7<br />
<span style="color: gray"># 1 + x:</span><br />
expr</td>
<td>expr: 1 + x;<br />
x: 3;<br />
<span style="color: gray">/* 1 + x: */</span><br />
expr;</td>
</tr>
<tr>
<td><a name="symbolic-expr-subst" id="symbolic-expr-subst"></a><a href="computer-algebra2#symbolic-expr-subst-note">substitute</a></td>
<td><span style="color: gray">(* {3, 3}: *)</span><br />
ReplaceAll[{x, x}, x -&gt; 3]<br />
<br />
<span style="color: gray">(* {3, 3}: *)</span><br />
{x, x} /. x -&gt; 3<br />
<br />
<span style="color: gray">(* {3, 4}: *)</span><br />
{x, y} /. {x -&gt; 3, y -&gt; 4}</td>
<td>Matrix([x, x]).subs(x, 3)</td>
<td>vector([x, x]).subs({x: 3})</td>
<td><span style="color: gray">/* [3, 3]: */</span><br />
subst(3, x, [x, x]);</td>
</tr>
<tr>
<td><a name="piecewise-symbolic-expr" id="piecewise-symbolic-expr"></a><a href="computer-algebra2#piecewise-symbolic-expr-note">piecewise-defined expression</a></td>
<td>Piecewise[<span style="white-space: pre-wrap;">{{x, x &gt;= 0}, {-x, x &lt; 0}}</span>]<br />
<br />
<span style="color: gray">(* otherwise case: *)</span><br />
Piecewise[<span style="white-space: pre-wrap;">{{-x, x &lt; 0}}</span>, x]</td>
<td>Piecewise((-x, x &lt; 0), (x, x &gt;= 0))<br />
<br />
<span style="color: gray"># otherwise case:</span><br />
Piecewise((-x, x &lt; 0), (x, True))</td>
<td>piecewise([<br />
<span style="white-space: pre-wrap;">  </span>((-infinity,0), -x),<br />
<span style="white-space: pre-wrap;">  </span>((0,infinity), x)])</td>
<td>if x &lt; 0 then -x else x;<br />
<br />
<span style="color: gray">/* integrating over piecewise-defined expression fails */</span></td>
</tr>
<tr>
<td><a name="simplify" id="simplify"></a><a href="computer-algebra2#simplify-note">simplify</a></td>
<td>Simplify[Cos[x]^2 + Sin[x]^2]<br />
<br />
<span style="color: gray">(* perform more simplications: *)</span><br />
FullSimplify[-(1/2) I E^(-I x) (-1 + E^(2 I x))]</td>
<td>simplify(cos(x)<span style="white-space: pre-wrap;">**</span>2 + sin(x)<span style="white-space: pre-wrap;">**</span>2)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="assumption" id="assumption"></a><a href="computer-algebra2#assumption-note">assumption</a></td>
<td>Simplify[Sqrt[x^2], Assumptions -&gt; x &gt;= 0]<br />
Simplify[(-1)^(n * (n + 1)),<br />
<span style="white-space: pre-wrap;">  </span>Assumptions -&gt; Element[n, Integers]]<br />
<br />
<span style="color: gray">(* perform fewer simplications: *)</span><br />
Refine[Sqrt[x^2], Assumptions -&gt; x &gt;= 0]<br />
Refine[(-1)^(n * (n + 1)), Element[n, Integers]]</td>
<td>x = symbols('x', positive=True)<br />
sqrt(x ** 2)<br />
<br />
n = symbols('n', integer=True)<br />
(-1)<span style="white-space: pre-wrap;">**</span>((n) * (n + 1))</td>
<td>assume(x &gt; 0)<br />
sqrt(x^2)</td>
<td>assume(x &gt; 0);<br />
sqrt(x^2);<br />
<br />
<span style="color: gray">/* There is no assumption predicate for<br />
<span style="white-space: pre-wrap;">   </span>integer variables. */</span></td>
</tr>
<tr>
<td><a name="assumption-predicates" id="assumption-predicates"></a><a href="computer-algebra2#assumption-predicates-note">assumption predicates</a></td>
<td>Element[x, Complexes]<br />
Element[x, Reals]<br />
Element[x, Algebraics]<br />
Element[x, Rationals]<br />
Element[x, Integers]<br />
Element[x, Primes]<br />
Element[x, Integers] &amp;&amp; Mod[x, 5] == 0<br />
Element[x, Booleans]<br />
<br />
<span style="color: gray">(* assumptions can use inequalities and logical operators: *)</span><br />
x &gt; 0 <span style="white-space: pre-wrap;">||</span> x &lt; 0</td>
<td><span style="color: gray"># a partial list:</span><br />
complex<br />
real<br />
algebraic<br />
rational<br />
integer<br />
positive<br />
nonpositive<br />
negative<br />
nonnegative<br />
nonzero<br />
prime<br />
odd<br />
even</td>
<td>assume(x, 'complex')<br />
assume(x, 'real')<br />
assume(x, 'rational')<br />
assume(x, 'integer')<br />
assume(x, 'odd')<br />
assume(x, 'even')</td>
<td><span style="color: gray"><em>Assumptions can only be created using relational operators.</em></span></td>
</tr>
<tr>
<td><a name="list-assumptions" id="list-assumptions"></a><a href="computer-algebra2#list-assumptions-note">list assumptions</a></td>
<td><span style="color: gray"><em>None. Assumptions are always local.</em></span></td>
<td>x.assumptions0</td>
<td>assumptions()</td>
<td>facts(x);<br />
<br />
<span style="color: gray"># assumptions on all symbols:</span><br />
facts();</td>
</tr>
<tr>
<td><a name="rm-assumption" id="rm-assumption"></a><a href="computer-algebra2#rm-assumption-note">remove assumption</a></td>
<td><span style="color: gray"><em>None. Assumptions are always local.</em></span></td>
<td><span style="color: gray"># removes all assumptions about x:</span><br />
x = symbols('x')</td>
<td>forget(x &gt; 0)<br />
<br />
<span style="color: gray"># rm all assumptions:</span><br />
forget()</td>
<td>forget(x &gt; 0);</td>
</tr>
<tr>
<th colspan="5"><a name="calculus" id="calculus"></a><a href="computer-algebra2#calculus-note">calculus</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="limit" id="limit"></a><a href="computer-algebra2#limit-note">limit</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Limit[Sin[x]/x, x -&gt; 0]</td>
<td>limit(sin(x)/x, x, 0)</td>
<td>limit(sin(x)/x, x=0)</td>
<td>limit(sin(x)/x, x, 0);</td>
</tr>
<tr>
<td><a name="limit-at-infinity" id="limit-at-infinity"></a><a href="computer-algebra2#limit-at-infinity-note">limit at infinity</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Limit[1/x, x -&gt; Infinity]</td>
<td>limit(1/x, x, oo)</td>
<td>limit(1/x, x=infinity)</td>
<td>limit(1/x, x, inf);</td>
</tr>
<tr>
<td><a name="one-sided-limit" id="one-sided-limit"></a><a href="computer-algebra2#one-sided-limit-note">one-sided limit</a><br />
<br />
<span style="color: gray"><em>from left, from right</em></span></td>
<td>Limit[1/x, x -&gt; 0, Direction -&gt; 1]<br />
Limit[1/x, x -&gt; 0, Direction -&gt; -1]</td>
<td>limit(1/x, x, 0, '-')<br />
limit(1/x, x, 0, '+')</td>
<td>limit(1/x, x=0, dir='-')<br />
limit(1/x, x=0, dir='+')</td>
<td>limit(1/x, x, 0, minus);<br />
limit(1/x, x, 0, plus);</td>
</tr>
<tr>
<td><a name="derivative" id="derivative"></a><a href="computer-algebra2#derivative-note">derivative</a></td>
<td>D[x^3 + x + 3, x]<br />
<br />
D[x^3 + x + 3, x] /. x -&gt; 2</td>
<td>diff(x<span style="white-space: pre-wrap;">**</span>3 + x + 3, x)<br />
<br />
diff(x<span style="white-space: pre-wrap;">**</span>3 + x + 3, x).subs(x, 2)</td>
<td>diff(x^3 + x + 3, x)<br />
<br />
diff(x^3 + x + 3, x).subs({x: 2})<br />
<br />
<span style="color: gray"># derivative is synonym of diff</span></td>
<td>diff(x^3 + x + 3, x);<br />
<br />
at(diff(x^3 + x + 3, x), [x=2]);</td>
</tr>
<tr>
<td><a name="derivative-func" id="derivative-func"></a><a href="computer-algebra2#derivative-func-note">derivative of a function</a></td>
<td>f[x_] = x^3 + x + 3<br />
<br />
<span style="color: gray">(* returns expression: *)</span><br />
D[f[x, x]]<br />
<br />
<span style="color: gray">(* return functions: *)</span><br />
f'<br />
Derivative[1][f]<br />
<br />
<span style="color: gray">(* evaluating derivative at a point: *)</span><br />
f'[2]<br />
Derivative[1][f][2]</td>
<td></td>
<td>f(x) = x^3 + x + 3<br />
<br />
diff(f)<br />
<br />
diff(f)(2)</td>
<td></td>
</tr>
<tr>
<td><a name="derivative-const" id="derivative-const"></a><a href="computer-algebra2#derivative-const-note">constants</a></td>
<td><span style="color: gray">(* a depends on x; b does not: *)</span><br />
D[a x + b, x, NonConstants -&gt; {a}]<br />
<br />
Dt[a x + b, x, Constants -&gt; {b}]</td>
<td></td>
<td></td>
<td><span style="color: gray">/* symbols constant unless declared with depends: */</span><br />
depends(a, x);<br />
diff(a * x + b, x);<br />
<br />
<span style="color: gray">/* makes a constant again: */</span><br />
remove(a, dependency);</td>
</tr>
<tr>
<td><a name="higher-order-derivative" id="higher-order-derivative"></a><a href="computer-algebra2#higher-order-derivative-note">higher order derivative</a></td>
<td>D[Log[x], {x, 3}]<br />
Log'''[x]<br />
Derivative[3][Log][x]</td>
<td>diff(log(x), x, 3)</td>
<td>diff(log(x), x, 3)</td>
<td>diff(log(x), x, 3);</td>
</tr>
<tr>
<td><a name="mixed-partial-derivative" id="mixed-partial-derivative"></a><a href="computer-algebra2#mixed-partial-derivative-note">mixed partial derivative</a></td>
<td>D[x^9 * y^8, x, y, y]<br />
D[x^9 * y^8, x, {y, 2}]</td>
<td>diff(x<span style="white-space: pre-wrap;">**</span>9 * y<span style="white-space: pre-wrap;">**</span>8, x, y, y)</td>
<td>diff(x^9 * y^8, x, 1).diff(y, 2)</td>
<td>diff(x^9 * y^8, x, 1, y, 2);</td>
</tr>
<tr>
<td><a name="div-grad-curl" id="div-grad-curl"></a><a href="computer-algebra2#div-grad-curl-note">div, grad, and curl</a></td>
<td>Div[{x^2, x * y, x * y * z}, {x, y, z}]<br />
<br />
Grad[2 * x * y * z^2, {x, y, z}]<br />
<br />
Curl[{x * y * z, y^2, 0}, {x, y, z}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="antiderivative" id="antiderivative"></a><a href="computer-algebra2#antiderivative-note">antiderivative</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Integrate[x^3 + x + 3, x]</td>
<td>integrate(x<span style="white-space: pre-wrap;">**</span>3 + x + 3, x)</td>
<td>integral(x^3 + x + 3, x)</td>
<td>integrate(x^3 + x + 3, x);</td>
</tr>
<tr>
<td><a name="definite-integral" id="definite-integral"></a><a href="computer-algebra2#definite-integral-note">definite integral</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Integrate[x^3 + x + 3, {x, 0, 1}]</td>
<td>integrate(x<span style="white-space: pre-wrap;">**</span>3 + x + 3, [x, 0, 1])</td>
<td>integral(x^3 + x + 3, x, 0, 1)</td>
<td>integrate(x^3 + x + 3, x, 0, 1);</td>
</tr>
<tr>
<td><a name="improper-integral" id="improper-integral"></a><a href="computer-algebra2#improper-integral-note">improper integral</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Integrate[Exp[-x], {x, 0, Infinity}]</td>
<td>integrate(exp(-x), (x, 0, oo))</td>
<td>integral(exp(-x), x, 0, infinity)</td>
<td>integrate(exp(-x), x, 0, inf);</td>
</tr>
<tr>
<td><a name="double-integral" id="double-integral"></a><a href="computer-algebra2#double-integral-note">double integral</a></td>
<td><span style="color: gray">(* integrates over y first: *)</span><br />
Integrate[x^2 + y^2, {x, 0, 1}, {y, 0, x}]</td>
<td>f = integrate(<span style="white-space: pre-wrap;">x**2 + y**2</span>, (y, 0, x))<br />
integrate(f, (x, 0, 1))</td>
<td>integral(integral(x^2+y^2, y, 0, x), x, 0, 1)</td>
<td>integrate(<br />
<span style="white-space: pre-wrap;">  </span>integrate(x^2+y^2, y, 0, x), x, 0, 1);</td>
</tr>
<tr>
<td><a name="find-poles" id="find-poles"></a><a href="computer-algebra2#find-poles-note">find poles</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="residue" id="residue"></a><a href="computer-algebra2#residue-note">residue</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Residue[1/(z - I), {z, I}]</td>
<td>residue(1/(z-I), z, I)</td>
<td>f(z) = 1/(z - I)<br />
f.maxima_methods().residue(z, I)</td>
<td>residue(1 / (z - %i), z, %i);</td>
</tr>
<tr>
<td><a name="sum" id="sum"></a><a href="computer-algebra2#sum-note">sum</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Sum[2^i, {i, 1, 10}]</td>
<td>Sum(2<span style="white-space: pre-wrap;">**</span>i, (i, 1, 10)).doit()</td>
<td>sum(2^i for i in (1..10))</td>
<td>sum(2^i, i, 1, 10);</td>
</tr>
<tr>
<td><a name="series-sum" id="series-sum"></a><a href="computer-algebra2#series-sum-note">series sum</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Sum[2^-n, {n, 1, Infinity}]</td>
<td>Sum(2<span style="white-space: pre-wrap;">**</span>(-n), (n, 1, oo)).doit()</td>
<td>sum(2^-n, n, 1, infinity)</td>
<td>sum(2^-n, n, 1, inf), simpsum;</td>
</tr>
<tr>
<td><a name="series-expansion-func" id="series-expansion-func"></a><a href="computer-algebra2#series-expansion-func-note">series expansion of function</a></td>
<td>Series[Cos[x], {x, 0, 10}]</td>
<td>series(cos(x), x, n=11)</td>
<td>taylor(cos(x), x, 0, 10)</td>
<td>taylor(cos(x), [x, 0, 10]);</td>
</tr>
<tr>
<td><a name="omitted-order-term" id="omitted-order-term"></a><a href="computer-algebra2#omitted-order-term-note">omitted order term</a></td>
<td>expr = 1 + x + x/2 + x^2/6 + O[x]^3<br />
<br />
<span style="color: gray">(* remove omitted order term: *)</span><br />
Normal[expr]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="product" id="product"></a><a href="computer-algebra2#product-note">product</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Product[2*i + 1, {i, 0, 9}]</td>
<td>Product(2*i + 1, (i, 0, 9)).doit()</td>
<td>prod(2*i + 1 for i in (0..9))</td>
<td>product(2*i + 1, i, 0, 9);</td>
</tr>
<tr>
<th colspan="5"><a name="equations-unknowns" id="equations-unknowns"></a><a href="computer-algebra2#equations-unknowns-note">equations and unknowns</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="solve-eqn" id="solve-eqn"></a><a href="computer-algebra2#solve-eqn-note">solve equation</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Solve[x^3 + x + 3 == 0, x]</td>
<td>solve(x<span style="white-space: pre-wrap;">**</span>3 + x + 3, x)</td>
<td>solve(x^3 + x + 3 == 0, x)</td>
<td>solve(x^3 + x + 3 = 0, x);</td>
</tr>
<tr>
<td><a name="solve-eqns" id="solve-eqns"></a><a href="computer-algebra2#solve-eqns-note">solve equations</a></td>
<td>Solve[x + y == 3 &amp;&amp; x == 2 * y,<br />
<span style="white-space: pre-wrap;">  </span>{x, y}]<br />
<br />
<span style="color: gray">(* or: *)</span><br />
Solve[{x + y == 3, x == 2 * y}, {x, y}]</td>
<td>solve([x + y - 3, 3*x - 2*y], [x, y])</td>
<td>solve([x + y == 3, x == 2*y], x, y)</td>
<td>solve([x + y = 3, x = 2*y], [x, y]);</td>
</tr>
<tr>
<td><a name="differential-eqn" id="differential-eqn"></a><a href="computer-algebra2#differential-eqn-note">differential equation</a></td>
<td>DSolve[y'[x] == y[x], y[x], x]</td>
<td>y = Function('y')<br />
<br />
dsolve(Derivative(y(x), x) - y(x), y(x))</td>
<td>y = function('y')(x)<br />
<br />
desolve(diff(y, x) == y, y)</td>
<td>desolve([diff(y(x), x) = y(x)], [y(x)]);</td>
</tr>
<tr>
<td><a name="differential-eqn-boundary-condition" id="differential-eqn-boundary-condition"></a><a href="computer-algebra2#differential-eqn-boundary-condition-note">differential equation with boundary condition</a></td>
<td>DSolve[{y'[x] == y[x], y[0] == 1}, y[x], x]<br />
<br />
DSolve[{y''[x] == y[x], y[0] == 1, y'[0] == 2},<br />
<span style="white-space: pre-wrap;">  </span>y[x], x]</td>
<td><span style="color: gray"><em>support for boundary conditions is limited</em></span></td>
<td>y = function('y')(x)<br />
<br />
<span style="color: gray"># y(0) = 1:</span><br />
desolve(diff(y, x) == y, y, [0, 1])<br />
<br />
<span style="color: gray"># y(0) = 1 and y'(0) = 2:</span><br />
desolve(diff(y, x, x) == y, y, [0, 1, 2])</td>
<td>atvalue(y(x), x=0, 1);<br />
desolve([diff(y(x), x) = y(x)], [y(x)]);</td>
</tr>
<tr>
<td><a name="differential-eqns" id="differential-eqns"></a><a href="computer-algebra2#differential-eqns-note">differential equations</a></td>
<td>eqn1 = x'[t] == x[t] - x[t] * y[t]<br />
eqn2 = y'[t] == x[t] * y[t] - y[t]<br />
DSolve[{eqn1, eqn2}, {x[t], y[t]}, t]</td>
<td></td>
<td></td>
<td>eqn1: diff(x(t), t) = x(t) - x(t) * y(t);<br />
eqn2: diff(y(t), t) = x(t) * y(t) - y(t);<br />
desolve([eqn1, eqn2], [x(t), y(t)]);</td>
</tr>
<tr>
<td><a name="recurrence-eqn" id="recurrence-eqn"></a><a href="computer-algebra2#recurrence-eqn-note">recurrence equation</a></td>
<td>eqns = {a[n + 2] == a[n + 1] + a[n],<br />
<span style="white-space: pre-wrap;">  </span>a[0] == 0,<br />
<span style="white-space: pre-wrap;">  </span>a[1] == 1}<br />
<br />
RSolve[eqns, a[n], n]<br />
<br />
<span style="color: gray">(* remove Fibonacci[] from solution: *)</span><br />
FunctionExpand[RSolve[eqns, a[n], n]]</td>
<td>n = symbols('n')<br />
a = Function('a')<br />
eqn = a(n+2) - a(n+1) - a(n)<br />
<br />
rsolve(eqn, a(n), {a(0): 0, a(1): 1})</td>
<td></td>
<td>solve_rec(a[n]=a[n-1]+a[n-2], a[n], a[0] = 0, a[1] = 1);</td>
</tr>
<tr>
<th colspan="5"><a name="optimization" id="optimization"></a><a href="computer-algebra2#optimization-note">optimization</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="minimize" id="minimize"></a><a href="computer-algebra2#minimize-note">minimize</a></td>
<td><span style="color: gray">(* returns list of two items: min value and rule<br />
<span style="white-space: pre-wrap;">   </span>transforming x to argmin *)</span><br />
Minimize[x^2 + 1, x]<br />
<br />
<span style="color: gray">(* 2 ways to get min value: *)</span><br />
Minimize[x^2 + 1, x][[1]]<br />
MinValue(x^2 + 1, x]<br />
<br />
<span style="color: gray">(* 2 ways to get argmin: *)</span><br />
x /. Minimize[x^2 + 1, x][[2]]<br />
ArgMin[x^2 + 1, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="maximize" id="maximize"></a><a href="computer-algebra2#maximize-note">maximize</a></td>
<td>Maximize[-x^4 + 3 x^3, x]<br />
<br />
Maxvalue[-x^4 + 3 x^3, x]<br />
ArgMax[-x^4 + 3 x^3, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="optimize-unknown-param" id="optimize-unknown-param"></a><a href="computer-algebra2#optimize-unknown-param-note">objective with unknown parameter</a></td>
<td><span style="color: gray">(* minval and argmin are expressions<br />
<span style="white-space: pre-wrap;">   </span>containing a: *)</span><br />
Minimize[(x - a)^2 + x, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="unbounded-behavior" id="unbounded-behavior"></a><a href="computer-algebra2#unbounded-behavior-note">unbounded behavior</a></td>
<td><span style="color: gray">(* MaxValue will be Infinity; MinValue will be<br />
<span style="white-space: pre-wrap;">   </span>-Infinity *)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="optimize-multiple-var" id="optimize-multiple-var"></a><a href="computer-algebra2#optimize-multiple-var-note">multiple variables</a></td>
<td><span style="color: gray">(* returns one solution: *)</span><br />
Minimize[x^4 - 2 x^2 + 2 y^4 - 3 y^2, {x, y}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="optimize-constraints" id="optimize-constraints"></a><a href="computer-algebra2#optimize-constraints-note">constraints</a></td>
<td>Minimize[{-x - 2 y^2, y^2 &lt;= 17, 2 x + y &lt;= 5},<br />
<span style="white-space: pre-wrap;">  </span>{x, y}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="infeasible-behavior" id="infeasible-behavior"></a><a href="computer-algebra2#infeasible-behavior-note">infeasible behavior</a></td>
<td><span style="color: gray">(* MaxValue will be -Infinity; MinValue will be<br />
<span style="white-space: pre-wrap;">   </span>Infinity; ArgMax or ArgMin will be<br />
<span style="white-space: pre-wrap;">   </span>Indeterminate *)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="optimize-int-var" id="optimize-int-var"></a><a href="computer-algebra2#optimize-int-var-note">integer variables</a></td>
<td>Maximize[{x^2 + 2*y,<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>x &gt;= 0, y &gt;= 0,<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>2 x + Pi * y &lt;= 4},<br />
<span style="white-space: pre-wrap;">  </span>{x, y}, Integers]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="vectors" id="vectors"></a><a href="computer-algebra2#vectors-note">vectors</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="vec-literal" id="vec-literal"></a><a href="computer-algebra2#vec-literal-note">vector literal</a></td>
<td><span style="color: gray">(* row vector is same as array: *)</span><br />
{1, 2, 3}</td>
<td><span style="color: gray"># column vector:</span><br />
Matrix([1, 2, 3])</td>
<td>vector([1, 2, 3])</td>
<td><span style="color: gray">/* row vector is same as array: */</span><br />
[1, 2, 3];</td>
</tr>
<tr>
<td><a name="const-vec" id="const-vec"></a><a href="computer-algebra2#const-vec-note">constant vector</a><br />
<br />
<span style="color: gray"><em>all zeros, all ones</em></span></td>
<td>Table[0, {i, 1, 100}]<br />
Table[1, {i, 1, 100}]</td>
<td>Matrix([0] * 100)<br />
Matrix([1] * 100)</td>
<td>vector([0] * 100)<br />
vector([1] * 100)</td>
<td>makelist(0, 100);<br />
makelist(1, 100);</td>
</tr>
<tr>
<td><a name="vec-coordinate" id="vec-coordinate"></a><a href="computer-algebra2#vec-coordinate-note">vector coordinate</a></td>
<td><span style="color: gray">(* indices start at one: *)</span><br />
{6, 7, 8}[[1]]</td>
<td>Matrix([6, 7, 8])[0]</td>
<td>vector([6, 7, 8])[0]</td>
<td>[6, 7, 8][1];</td>
</tr>
<tr>
<td><a name="vec-dim" id="vec-dim"></a><a href="computer-algebra2#vec-dim-note">vector dimension</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Length[{1, 2, 3}]</td>
<td>len(Matrix([6, 7, 8]))<br />
Matrix([6, 7, 8]).shape[0]</td>
<td>len(vector([1, 2, 3]))</td>
<td>length([1, 2, 3]);</td>
</tr>
<tr>
<td><a name="vec-element-wise" id="vec-element-wise"></a><a href="computer-algebra2#vec-element-wise-note">element-wise arithmetic operators</a></td>
<td>+ - * /<br />
<span style="color: gray"><em>adjacent lists are multiplied element-wise</em></span></td>
<td>+ -<br />
<br />
<span style="color: gray"># element-wise multiplication:</span><br />
A = Matrix([1, 2, 3])<br />
B = Matrix([2, 3, 4])<br />
A.multiply_elementwise(B)</td>
<td>+ -</td>
<td>+ - * /</td>
</tr>
<tr>
<td><a name="vec-length-mismatch" id="vec-length-mismatch"></a><a href="computer-algebra2#vec-length-mismatch-note">vector length mismatch</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>error</em></span></td>
<td><span style="color: gray"><em>raises</em> ShapeError</span></td>
<td><span style="color: gray"><em>raises</em> TypeError</span></td>
<td><span style="color: gray"><em>error</em></span></td>
</tr>
<tr>
<td><a name="vec-scalar" id="vec-scalar"></a><a href="computer-algebra2#vec-scalar-note">scalar multiplication</a></td>
<td>3 {1, 2, 3}<br />
{1, 2, 3} 3<br />
<span style="color: gray"><em>* may also be used</em></span></td>
<td>3 * Matrix([1, 2, 3])<br />
Matrix([1, 2, 3]) * 3</td>
<td>3 * vector([1, 2, 3])<br />
vector([1, 2, 3]) * 3</td>
<td>3 * [1, 2, 3];<br />
[1, 2, 3] * 3;</td>
</tr>
<tr>
<td><a name="vec-dot" id="vec-dot"></a><a href="computer-algebra2#vec-dot-note">dot product</a></td>
<td>{1, 1, 1} . {2, 2, 2}<br />
Dot[{1, 1, 1}, {2, 2, 2}]</td>
<td>v1 = Matrix([1, 1, 1])<br />
v2 = Matrix([2, 2, 2])<br />
v1.dot(v2)</td>
<td>vector([1, 1, 1]) * vector([2, 2, 2])<br />
vector([1,1,1]).dot_product(vector([2,2,2]))</td>
<td>[1, 1, 1] . [2, 2, 2];</td>
</tr>
<tr>
<td><a name="vec-cross" id="vec-cross"></a><a href="computer-algebra2#vec-cross-note">cross product</a></td>
<td>Cross[{1, 0, 0}, {0, 1, 0}]</td>
<td>e1 = Matrix([1, 0, 0])<br />
e2 = Matrix([0, 1, 0])<br />
e1.cross(e2)</td>
<td>e1 = vector([1, 0, 0])<br />
e2 = vector([0, 1, 0])<br />
e1.cross_product(e2)</td>
<td></td>
</tr>
<tr>
<td><a name="vec-norms" id="vec-norms"></a><a href="computer-algebra2#vec-norms-note">norms</a></td>
<td>Norm[{1, 2, 3}, 1]<br />
Norm[{1, 2, 3}]<br />
Norm[{1, 2, 3}, Infinity]</td>
<td>vec = Matrix([1, 2, 3])<br />
<br />
vec.norm(1)<br />
vec.norm()<br />
vec.norm(inf)</td>
<td>vector([1, 2, 3]).norm(1)<br />
vector([1, 2, 3]).norm()<br />
vector([1, 2, 3]).norm(infinity)</td>
<td></td>
</tr>
<tr>
<td><a name="orthonormal-basis" id="orthonormal-basis"></a><a href="computer-algebra2#orthonormal-basis-note">orthonormal basis</a></td>
<td>Orthogonalize[<span style="white-space: pre-wrap;">{{1, 0, 1}, {1, 1, 1}}</span>]</td>
<td></td>
<td>A = matrix([[1, 0, 1], [1, 1, 1]]<br />
<br />
<span style="color: gray"># Rows of B are orthogonal and span same<br />
# space as rows of A. 2nd return value<br />
# expresses rows of A as linear combos<br />
# of rows of B.</span><br />
B, _ = A.gram_schmidt()</td>
<td>load(eigen);<br />
<br />
gramschmidt([[1, 0, 1], [1, 1, 1]]);</td>
</tr>
<tr>
<th colspan="5"><a name="matrices" id="matrices"></a><a href="computer-algebra2#matrices-note">matrices</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="matrix-literal-ctor" id="matrix-literal-ctor"></a><a href="computer-algebra2#matrix-literal-ctor-note">literal or constructor</a></td>
<td><span style="color: gray">(* used a nested array for each row: *)</span><br />
<span style="white-space: pre-wrap;">{{</span>1, 2}, {3, 4<span style="white-space: pre-wrap;">}}</span><br />
<br />
<span style="color: gray">(* display as grid with aligned columns: *)</span><br />
MatrixForm[<span style="white-space: pre-wrap;">{{</span>1, 2}, {3, 4<span style="white-space: pre-wrap;">}}</span>]</td>
<td>Matrix([[1, 2], [3, 4]])</td>
<td>matrix([[1, 2], [3, 4]])</td>
<td>matrix([1, 2], [3, 4]);</td>
</tr>
<tr>
<td><a name="matrix-from-seq" id="matrix-from-seq"></a><a href="computer-algebra2#matrix-from-seq-note">construct from sequence</a></td>
<td>ArrayReshape[{1, 2, 3, 4, 5, 6}, {2, 3}]</td>
<td>Matrix(2, 3, [1, 2, 3, 4, 5, 6])</td>
<td>matrix([1, 2, 3, 4, 5, 6], nrows=2)</td>
<td></td>
</tr>
<tr>
<td><a name="const-matrices" id="const-matrices"></a><a href="computer-algebra2#const-matrices-note">constant matrices</a><br />
<br />
<span style="color: gray"><em>all zeros, all ones</em></span></td>
<td>Table[0, {i, 3}, {j, 3}]<br />
Table[1, {i, 3}, {j, 3}]</td>
<td>zeros(3, 3)<br />
ones(3, 3)</td>
<td>matrix([0] * 9, nrows=3)<br />
matrix([1] * 9, nrows=3)</td>
<td>zeromatrix(3, 3);<br />
<br />
f[i, j] := 1;<br />
genmatrix(f, 3, 3);</td>
</tr>
<tr>
<td><a name="diagonal-matrices" id="diagonal-matrices"></a><a href="computer-algebra2#diagonal-matrices-note">diagonal matrices</a><br />
<span style="color: gray"><em>and identity</em></span></td>
<td>DiagonalMatrix[{1, 2, 3}]<br />
IdentityMatrix[3]</td>
<td>diag(*[1, 2, 3])<br />
eye(3)</td>
<td>diag = [1, 2, 3]<br />
d = {(i, i): v for (i, v) in enumerate(diag)}<br />
Matrix(3, 3, d)<br />
<br />
matrix.identity(3)</td>
<td>ident(3) * [1, 2, 3];<br />
ident(3);</td>
</tr>
<tr>
<td><a name="matrix-formula" id="matrix-formula"></a><a href="computer-algebra2#matrix-formula-note">matrix by formula</a></td>
<td>Table[1/(i + j - 1), {i, 1, 3}, {j, 1, 3}]</td>
<td></td>
<td>Matrix(3, 3, lambda i, j: 1/(i + j + 1))</td>
<td>h2[i, j] := 1/(i + j -1);<br />
genmatrix(h2, 3, 3);</td>
</tr>
<tr>
<td><a name="matrix-dim" id="matrix-dim"></a><a href="computer-algebra2#matrix-dim-note">dimensions</a></td>
<td><span style="color: gray">(* returns {3, 2}: *)</span><br />
Dimensions[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}, {5, 6}}</span>]</td>
<td>A = matrix([[1, 2], [3, 4], [5, 6]])<br />
<br />
<span style="color: gray"># returns (3, 2):</span><br />
A.shape</td>
<td>A = matrix([[1, 2], [3, 4], [5, 6]])<br />
A.nrows()<br />
A.ncols()</td>
<td>A: matrix([1, 2, 3], [4, 5, 6]);<br />
matrix_size(A);</td>
</tr>
<tr>
<td><a name="matrix-elem-lookup" id="matrix-elem-lookup"></a><a href="computer-algebra2#matrix-elem-lookup-note">element lookup</a></td>
<td><span style="color: gray">(* top left corner: *)</span><br />
<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>[[1, 1]]</td>
<td>A = Matrix([[1, 2], [3, 4]])<br />
<br />
<span style="color: gray"># top left corner:</span><br />
A[0, 0]</td>
<td>A = matrix([[1, 2], [3, 4]])<br />
A[0, 0]<br />
A[0][0]</td>
<td>A: matrix([1, 2], [3, 4]);<br />
<br />
A[1, 1];<br />
A[1][1];</td>
</tr>
<tr>
<td><a name="extract-matrix-row" id="extract-matrix-row"></a><a href="computer-algebra2#extract-matrix-row-note">extract row</a></td>
<td><span style="color: gray">(* first row: *)</span><br />
<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>[[1]]</td>
<td><span style="color: gray"># first row:</span><br />
A[0, :]</td>
<td><span style="color: gray"># first row as vector:</span><br />
A[0]<br />
A.rows()[0]</td>
<td>row(matrix([1, 2], [3, 4]), 1);<br />
matrix([1, 2], [3, 4])[1];</td>
</tr>
<tr>
<td><a name="extract-matrix-col" id="extract-matrix-col"></a><a href="computer-algebra2#extract-matrix-col-note">extract column</a></td>
<td><span style="color: gray">(* first column as array: *)</span><br />
<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>[[All, 1]]</td>
<td><span style="color: gray"># first column as 1x2 matrix:</span><br />
A[:, 0]</td>
<td><span style="color: gray"># first column as vector:</span><br />
A.columns()[0]</td>
<td>col(matrix([1, 2], [3, 4]), 1);</td>
</tr>
<tr>
<td><a name="extract-submatrix" id="extract-submatrix"></a><a href="computer-algebra2#extract-submatrix-note">extract submatrix</a></td>
<td>A = <span style="white-space: pre-wrap;">{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}</span><br />
A[[1;;2, 1;;2]]</td>
<td>rows = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]<br />
A = Matrix(rows)<br />
A[0:2, 0:2]</td>
<td>A = matrix(range(1, 10), nrows=3)<br />
<br />
<span style="color: gray"># takes two lists of indices:</span><br />
A.matrix_from_rows_and_columns([0, 1], [0, 1])</td>
<td></td>
</tr>
<tr>
<td><a name="matrix-scalar-mult" id="matrix-scalar-mult"></a><a href="computer-algebra2#matrix-scalar-mult-note">scalar multiplication</a></td>
<td>3 * <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span> * 3</td>
<td>3 * Matrix([[1, 2], [3, 4]])<br />
Matrix([[1, 2], [3, 4]]) * 3</td>
<td>3 * matrix([[1, 2], [3, 4]])<br />
matrix([[1, 2], [3, 4]]) * 3</td>
<td>3 * matrix([1, 2], [3, 4]);<br />
matrix([1, 2], [3, 4]) * 3;</td>
</tr>
<tr>
<td><a name="matrix-elem-wise-op" id="matrix-elem-wise-op"></a><a href="computer-algebra2#matrix-elem-wise-op-note">element-wise operators</a></td>
<td>+ - * /<br />
<span style="color: gray"><em>adjacent matrices are multiplied element-wise</em></span></td>
<td>+ -<br />
<br />
<span style="color: gray"># for Hadamard product:</span><br />
A.multiply_elementwise(B)</td>
<td>+ -</td>
<td>+ - * /</td>
</tr>
<tr>
<td><a name="matrix-mult" id="matrix-mult"></a><a href="computer-algebra2#matrix-mult-note">product</a></td>
<td>A = <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
B = <span style="white-space: pre-wrap;">{{4, 3}, {2, 1}}</span><br />
Dot[A, B]<br />
<span style="color: gray">(* or use period: *)</span><br />
A . B</td>
<td>A = matrix([[1, 2], [3, 4]])<br />
B = matrix([[4, 3], [2, 1]])<br />
A * B</td>
<td>A = matrix([[1, 2], [3, 4]])<br />
B = matrix([[4, 3], [2, 1]])<br />
A * B</td>
<td>A: matrix([1, 2], [3, 4]);<br />
B: matrix([4, 3], [2, 1]);<br />
A . B;</td>
</tr>
<tr>
<td><a name="matrix-vec-mult" id="matrix-vec-mult"></a><a href="computer-algebra2#matrix-vec-mult-note">multiply by vector</a></td>
<td><span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span> . {7, 8}<br />
Dot[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>, {5, 6}]</td>
<td></td>
<td>matrix([[1, 2], [3, 4]]) * vector([5, 6])</td>
<td>matrix([1, 2], [3, 4]) . transpose([5, 6]);</td>
</tr>
<tr>
<td><a name="matrix-power" id="matrix-power"></a><a href="computer-algebra2#matrix-power-note">power</a></td>
<td>MatrixPower[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>, 3]<br />
<br />
<span style="color: gray">(* element-wise operator: *)</span><br />
A ^ 3</td>
<td>A <span style="white-space: pre-wrap;">**</span> 3</td>
<td>A ^ 3<br />
A <span style="white-space: pre-wrap;">**</span> 3</td>
<td>matrix([1, 2], [3, 4]) <span style="white-space: pre-wrap;">^^</span> 3;</td>
</tr>
<tr>
<td><a name="matrix-exponential" id="matrix-exponential"></a><a href="computer-algebra2#matrix-exponential-note">exponential</a></td>
<td>MatrixExp[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td></td>
<td>exp(matrix([[1, 2], [3, 4]]))</td>
<td></td>
</tr>
<tr>
<td><a name="matrix-log" id="matrix-log"></a><a href="computer-algebra2#matrix-log-note">log</a></td>
<td>MatrixLog[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="kronecker-prod" id="kronecker-prod"></a><a href="computer-algebra2#kronecker-prod-note">kronecker product</a></td>
<td>A = <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
B = <span style="white-space: pre-wrap;">{{4, 3}, {2, 1}}</span><br />
KroneckerProduct[A, B]</td>
<td></td>
<td>A = matrix([[1, 2], [3, 4]])<br />
B = matrix([[4, 3], [2, 1]])<br />
A.tensor_product(B)</td>
<td>A: matrix([1, 2], [3, 4]);<br />
B: matrix([4, 3], [2, 1]);<br />
kronecker_product(A, B);</td>
</tr>
<tr>
<td><a name="matrix-norms" id="matrix-norms"></a><a href="computer-algebra2#matrix-norms-note">norms</a></td>
<td>A = <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
<br />
Norm[A, 1]<br />
Norm[A, 2]<br />
Norm[A, Infinity]<br />
Norm[A, "Frobenius"]</td>
<td></td>
<td>A = matrix([[1, 2], [3, 4]])<br />
<br />
<span style="color: gray"># floating point values:</span><br />
A.norm(1)<br />
A.norm()<br />
A.norm(infinity)<br />
A.norm('frob')</td>
<td>A: matrix([1, 2], [3, 4]);<br />
<br />
mat_norm(A, 1);<br />
<span style="color: gray">/* none */</span><br />
mat_norm(A, inf);<br />
mat_norm(A, frobenius);</td>
</tr>
<tr>
<td><a name="matrix-transpose" id="matrix-transpose"></a><a href="computer-algebra2#matrix-transpose-note">transpose</a></td>
<td>Transpose[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]<br />
<br />
<span style="color: gray">(* or ESC tr ESC for T exponent notation *)</span></td>
<td>A.T</td>
<td>A.transpose()</td>
<td>transpose(A);</td>
</tr>
<tr>
<td><a name="matrix-conjugate-transpose" id="matrix-conjugate-transpose"></a><a href="computer-algebra2#matrix-conjugate-transpose-note">conjugate transpose</a></td>
<td>A = <span style="white-space: pre-wrap;">{{1, I}, {2, -I}}</span><br />
ConjugateTranspose[A]<br />
<br />
<span style="color: gray">(* or ESC ct ESC for dagger exponent notation *)</span></td>
<td>M = Matrix([[1, I], [2, -I]])<br />
M.adjoint()</td>
<td>M = matrix([[1, I], [2, -I]])<br />
M.conjugate_transpose()</td>
<td>ctranspose(matrix([1, %i], [2, -%i]));</td>
</tr>
<tr>
<td><a name="matrix-inverse" id="matrix-inverse"></a><a href="computer-algebra2#matrix-inverse-note">inverse</a></td>
<td>Inverse[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]<br />
<br />
<span style="color: gray">(* expression left unevaluated: *)</span><br />
Inverse[<span style="white-space: pre-wrap;">{{1, 0}, {0, 0}}</span>]</td>
<td>A.inv()<br />
<br />
<span style="color: gray"># raises ValueError:</span><br />
Matrix([[1, 0], [0, 0]]).inv()</td>
<td>A.inverse()<br />
A ^ -1<br />
A ** -1</td>
<td>invert(A);<br />
A <span style="white-space: pre-wrap;">^^</span> -1;<br />
<br />
<span style="color: gray">/* error: */</span><br />
invert(matrix([1, 0], [0, 0]));</td>
</tr>
<tr>
<td><a name="row-echelon-form" id="row-echelon-form"></a><a href="computer-algebra2#row-echelon-form-note">row echelon form</a></td>
<td>RowReduce[<span style="white-space: pre-wrap;">{{1, 1}, {1, 1}}</span>]</td>
<td></td>
<td>matrix([[1, 1], [1, 1]]).echelon_form()</td>
<td>echelon(matrix([1, 1], [1, 1]));</td>
</tr>
<tr>
<td><a name="pseudoinverse" id="pseudoinverse"></a><a href="computer-algebra2#pseudoinverse-note">pseudoinverse</a></td>
<td>PseudoInverse[<span style="white-space: pre-wrap;">{{1, 0}, {3, 0}}</span>]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="determinant" id="determinant"></a><a href="computer-algebra2#determinant-note">determinant</a></td>
<td>Det[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td>A.det()</td>
<td>A.determinant()</td>
<td>determinant(A);</td>
</tr>
<tr>
<td><a name="trace" id="trace"></a><a href="computer-algebra2#trace-note">trace</a></td>
<td>Tr[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td></td>
<td>A.trace()</td>
<td>load("nchrpl");<br />
<br />
mattrace(matrix([1, 2], [3, 4]));</td>
</tr>
<tr>
<td><a name="characteristic-polynomial" id="characteristic-polynomial"></a><a href="computer-algebra2#characteristic-polynomial-note">characteristic polynomial</a></td>
<td>CharacteristicPolynomial[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>, x]</td>
<td></td>
<td>matrix([[1, 2], [3, 4]]).charpoly('x')</td>
<td>A: matrix([1, 2], [3, 4]);<br />
<br />
charpoly(A, x);</td>
</tr>
<tr>
<td><a name="minimal-polynomial" id="minimal-polynomial"></a><a href="computer-algebra2#minimal-polynomial-note">minimal polynomial</a></td>
<td></td>
<td></td>
<td>matrix.identity(3).minpoly('x')</td>
<td>load(diag);<br />
<br />
minimalPoly(jordan(ident(3)));</td>
</tr>
<tr>
<td><a name="matrix-rank" id="matrix-rank"></a><a href="computer-algebra2#matrix-rank-note">rank</a></td>
<td>MatrixRank[<span style="white-space: pre-wrap;">{{1, 1}, {0, 0}}</span>]</td>
<td></td>
<td>matrix([[1, 1], [0, 0]]).rank()</td>
<td>rank(matrix([1, 1], [0, 0]));</td>
</tr>
<tr>
<td><a name="nullspace-basis" id="nullspace-basis"></a><a href="computer-algebra2#nullspace-basis-note">nullspace basis</a></td>
<td>NullSpace[<span style="white-space: pre-wrap;">{{1, 1}, {0, 0}}</span>]</td>
<td></td>
<td></td>
<td>nullspace(matrix([1, 1], [0, 0]));</td>
</tr>
<tr>
<td><a name="eigenval" id="eigenval"></a><a href="computer-algebra2#eigenval-note">eigenvalues</a></td>
<td>Eigenvalues[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td>A.eigenvals()</td>
<td>matrix([[1, 2], [3, 4]]).eigenvalues()</td>
<td><span style="color: gray">/* returns list of two lists:<br />
<span style="white-space: pre-wrap;">   </span>first is the eigenvalues,<br />
<span style="white-space: pre-wrap;">   </span>second is their multiplicities */</span><br />
eigenvalues(A);</td>
</tr>
<tr>
<td><a name="eigenvec" id="eigenvec"></a><a href="computer-algebra2#eigenvec-note">eigenvectors</a></td>
<td>Eigenvectors[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td>A.eigenvects()</td>
<td>A = matrix([[1, 2], [3, 4]])<br />
<br />
<span style="color: gray"># returns list of triples:<br />
# (eigenval, eigenvec, multiplicity)</span><br />
A.eigenvectors_right()</td>
<td><span style="color: gray">/* returns list of two lists. The first item is the return value of eigenvalues(). The second item is a list containing a list of eigenvectors for each eigenvalue. */</span><br />
eigenvectors(A);</td>
</tr>
<tr>
<td><a name="lu-decomposition" id="lu-decomposition"></a><a href="computer-algebra2#lu-decomposition-note">LU decomposition</a></td>
<td>{lu, p, c} = LUDecomposition[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]<br />
L = LowerTriangularize[lu]<br />
U = UpperTriangularize[lu]<br />
P = Permute[IdentityMatrix[2], p]</td>
<td></td>
<td>P, L, U = matrix([[1, 2], [3, 4]]).LU()</td>
<td>A: matrix([1, 2], [3, 4]);<br />
[P, L, U]: get_lu_factors(lu_factor(A));</td>
</tr>
<tr>
<td><a name="qr-decomposition" id="qr-decomposition"></a><a href="computer-algebra2#qr-decomposition-note">QR decomposition</a></td>
<td>A := <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
{Q, R} = QRDecomposition[A]<br />
A == Q . R</td>
<td></td>
<td><span style="color: gray"># numerical result:</span><br />
Q, R = matrix(CDF, [[1, 2], [3, 4]]).QR()</td>
<td></td>
</tr>
<tr>
<td><a name="spectral-decomposition" id="spectral-decomposition"></a><a href="computer-algebra2#spectral-decomposition-note">spectral decomposition</a></td>
<td>A = <span style="white-space: pre-wrap;">{{1, 2}, {2, 1}}</span><br />
z := Eigensystem[A]<br />
d := DiagonalMatrix[z[[1]]]<br />
P := Transpose[z[[2]]]<br />
<br />
P . d . Inverse[P] == A</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="svd" id="svd"></a><a href="computer-algebra2#svd-note">singular value decomposition</a></td>
<td>A := <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
z := SingularValueDecomposition[A]<br />
U := z[[1]]<br />
S := z[[2]]<br />
V := z[[3]]<br />
<br />
N[A] == N[U . S . ConjugateTranspose[V]]</td>
<td></td>
<td>A = matrix(CDF, [[1, 2], [3, 4]])<br />
<span style="color: gray"># numerical result:</span><br />
U, D, V = A.SVD()<br />
norm(A - U * D * V.conjugate_transpose())</td>
<td></td>
</tr>
<tr>
<td><a name="jordan-decomposition" id="jordan-decomposition"></a><a href="computer-algebra2#jordan-decomposition-note">jordan decomposition</a></td>
<td>A := <span style="white-space: pre-wrap;">{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}</span><br />
z := JordanDecomposition[A]<br />
P := z[[1]]<br />
J := z[[2]]<br />
A . P == P . J</td>
<td></td>
<td>A = matrix([[0, 1], [1, 0]])<br />
<br />
<span style="color: gray"># eigenvalues must be rational:</span><br />
J, P = A.jordan_form(<br />
<span style="white-space: pre-wrap;">  </span>subdivide=False, transformation=True)</td>
<td></td>
</tr>
<tr>
<td><a name="polar-decomposition" id="polar-decomposition"></a><a href="computer-algebra2#polar-decomposition-note">polar decomposition</a></td>
<td>A := <span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span><br />
{u, s, v} := SingularValueDecomposition[A]<br />
vt := ConjugateTranspose[v]<br />
<br />
U := u * vt<br />
P = v * s * vt</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="combinatorics" id="combinatorics"></a><a href="computer-algebra2#combinatorics-note">combinatorics</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="factorial" id="factorial"></a><a href="computer-algebra2#factorial-note">factorial</a><br />
<br />
<span style="color: gray"><em>and permutations</em></span></td>
<td>5!<br />
Factorial[5]<br />
<br />
Permutations[Range[1, 5]]</td>
<td>factorial(5)</td>
<td>factorial(5)<br />
5.factorial()</td>
<td>5!<br />
factorial(5);</td>
</tr>
<tr>
<td><a name="binomial-coefficient" id="binomial-coefficient"></a><a href="computer-algebra2#binomial-coefficient-note">binomial coefficient</a><br />
<br />
<span style="color: gray"><em>and combinations</em></span></td>
<td>Binomial[10, 3]</td>
<td>binomial(10, 3)</td>
<td>binomial(10, 3)</td>
<td>binomial(10, 3);</td>
</tr>
<tr>
<td><a name="multinomial-coefficient" id="multinomial-coefficient"></a><a href="computer-algebra2#multinomial-coefficient-note">multinomial coefficient</a></td>
<td>Multinomial[3, 4, 5]</td>
<td></td>
<td>multinomial([3, 4, 5])</td>
<td>multinomial(12, [3, 4, 5]);</td>
</tr>
<tr>
<td><a name="rising-falling-factorial" id="rising-falling-factorial"></a><a href="computer-algebra2#rising-falling-factorial-note">rising and falling factorial</a></td>
<td>Pochhammer[1/2, 3]<br />
<br />
FactorialPower[1/2, 3]</td>
<td></td>
<td>rising_factorial(1/2, 3)<br />
<br />
falling_factorial(1/2, 3)</td>
<td>pochhammer(1/2, 3);<br />
<br />
pochhammer(1/2 - 2, 3);</td>
</tr>
<tr>
<td><a name="subfactorial" id="subfactorial"></a><a href="computer-algebra2#subfactorial-note">subfactorial</a><br />
<br />
<span style="color: gray"><em>and derangments</em></span></td>
<td>Needs["Combinatorica<span style="white-space: pre-wrap;">`</span>"]<br />
<br />
NumberOfDerangements[10]</td>
<td>subfactorial(10)</td>
<td>subfactorial(10)</td>
<td></td>
</tr>
<tr>
<td><a name="int-partitions" id="int-partitions"></a><a href="computer-algebra2#int-partitions-note">integer partitions</a></td>
<td><span style="color: gray">(* number of partitions: *)</span><br />
PartitionsP[10]<br />
<br />
<span style="color: gray">(* the partitions as an array: *)</span><br />
IntegerPartitions[10]</td>
<td>from sympy.utilities.iterables \<br />
<span style="white-space: pre-wrap;">  </span>import partitions<br />
<br />
len(list(partitions(10)))<br />
<br />
[p.copy() for p in partitions(10)]</td>
<td>Partitions(10).cardinality()<br />
Partitions(10).list()</td>
<td>length(integer_partitions(10));<br />
<br />
<span style="color: gray">/* the partitions as an array: */</span><br />
integer_partitions(10);<br />
<br /></td>
</tr>
<tr>
<td><a name="compositions" id="compositions"></a><a href="computer-algebra2#compositions-note">compositions</a></td>
<td>Needs["Combinatorica<span style="white-space: pre-wrap;">`</span>"]<br />
<br />
<span style="color: gray">(* weak compositions of size 3 is 66: *)</span><br />
NumberOfCompositions[10, 3]<br />
<br />
Compositions[10, 3]</td>
<td></td>
<td><span style="color: gray"># compositions of all lengths:</span><br />
Compositions(10).cardinality()<br />
<br />
Compositions(10).list()<br />
<br />
<span style="color: gray"># of length 3:</span><br />
Compositions(10, min_length=3,<br />
<span style="white-space: pre-wrap;">  </span>max_length=3).list()</td>
<td></td>
</tr>
<tr>
<td><a name="set-partitions" id="set-partitions"></a><a href="computer-algebra2#set-partitions-note">set partitions</a></td>
<td>StirlingS2[10, 3]<br />
<br />
Needs["Combinatorica<span style="white-space: pre-wrap;">`</span>"]<br />
<br />
KSetPartitions[10, 3]<br />
SetPartititions[10]</td>
<td></td>
<td>stirling_number2(10, 3)</td>
<td>stirling2(10, 3);</td>
</tr>
<tr>
<td><a name="bell-num" id="bell-num"></a><a href="computer-algebra2#bell-num-note">bell number</a></td>
<td>BellB[10]</td>
<td>bell(10)</td>
<td>bell_number(10)</td>
<td>belln(10);</td>
</tr>
<tr>
<td><a name="permutations-k-disjoint-cycles" id="permutations-k-disjoint-cycles"></a><a href="computer-algebra2#permutations-k-disjoint-cyclces">permutations with k disjoint cycles</a></td>
<td>Abs[StirlingS1[10, 3]]</td>
<td></td>
<td>stirling_number1(10, 3)</td>
<td>abs(stirling1(10, 3));</td>
</tr>
<tr>
<td><a name="fibonacci-num" id="fibonacci-num"></a><a href="computer-algebra2#fibonacci-num-note">fibonacci number</a><br />
<br />
<span style="color: gray"><em>and lucas number</em></span></td>
<td>Fibonacci[10]<br />
LucasL[10]</td>
<td>fibonacci(10)<br />
lucas(10)</td>
<td>fibonacci(10)<br />
lucas_number2(10, 1, -1)</td>
<td>fib(10);<br />
lucas(10);</td>
</tr>
<tr>
<td><a name="bernoulli-num" id="bernoulli-num"></a><a href="computer-algebra2#bernoulli-num-note">bernoulli number</a></td>
<td>BernoulliB[100]</td>
<td>bernoulli(100)</td>
<td>bernoulli(100)</td>
<td>bern(100);</td>
</tr>
<tr>
<td><a name="harmonic-num" id="harmonic-num"></a><a href="computer-algebra2#harmonic-num-note">harmonic number</a></td>
<td>HarmonicNumber[100]</td>
<td>harmonic(100)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="catalan-num" id="catalan-num"></a><a href="computer-algebra2#catalan-num-note">catalan number</a></td>
<td>CatalanNumber[10]</td>
<td>catalan(10)</td>
<td>catalan_number(10)</td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="number-theory" id="number-theory"></a><a href="computer-algebra2#number-theory-note">number theory</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="divisible-test" id="divisible-test"></a><a href="computer-algebra2#divisible-test-note">divisible test</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Divisible[1001, 7]</td>
<td>1001 % 7 == 0</td>
<td>7.divides(1001)</td>
<td>is(mod(1001, 7) = 0);</td>
</tr>
<tr>
<td><a name="divisors" id="divisors"></a><a href="computer-algebra2#divisors-note">divisors</a></td>
<td><span style="color: gray">(* {1, 2, 4, 5, 10, 20, 25, 50, 100}: *)</span><br />
Divisors[100]</td>
<td>ntheory.divisors(100)</td>
<td>divisors(100)</td>
<td>divisors(100);</td>
</tr>
<tr>
<td><a name="pseudoprime-test" id="pseudoprime-test"></a><a href="computer-algebra2#pseudoprime-test-note">pseudoprime test</a></td>
<td>PrimeQ[7]</td>
<td>ntheory.primetest.isprime(7)<br />
ntheory.primetest.mr(7, [2, 3])</td>
<td>is_prime(7)<br />
is_pseudoprime(7)</td>
<td>primep(7);</td>
</tr>
<tr>
<td><a name="prime-factors" id="prime-factors"></a><a href="computer-algebra2#prime-factors">prime factors</a></td>
<td><span style="color: gray">(* returns <span style="white-space: pre-wrap;">{{</span>2, 2}, {3, 1}, {7, 1}} *)</span><br />
FactorInteger[84]</td>
<td><span style="color: gray"># {2: 2, 3: 1, 7: 1}:</span><br />
ntheory.factorint(84)</td>
<td><span style="color: gray"># 2^2 * 3 * 7:</span><br />
factor(84)</td>
<td><span style="color: gray">/* 2^2 3 7: */</span><br />
factor(84);<br />
<br />
<span style="color: gray">/* [[2,2],[3,1],[7,1]]: */</span><br />
ifactors(84);</td>
</tr>
<tr>
<td><a name="next-prime" id="next-prime"></a><a href="computer-algebra2#next-prime-note">next prime</a><br />
<br />
<span style="color: gray"><em>and preceding</em></span></td>
<td>NextPrime[1000]<br />
NextPrime[1000, -1]</td>
<td>ntheory.generate.nextprime(1000)<br />
ntheory.generate.prevprime(1000)</td>
<td>next_prime(1000)<br />
previous_prime(1000)</td>
<td>next_prime(1000);<br />
prev_prime(1000);</td>
</tr>
<tr>
<td><a name="nth-prime" id="nth-prime"></a><a href="computer-algebra2#nth-prime-note">nth prime</a></td>
<td><span style="color: gray">(* 541: *)</span><br />
Prime[100]</td>
<td>ntheory.generate.prime(100)</td>
<td>primes_first_n(100)[-1]</td>
<td></td>
</tr>
<tr>
<td><a name="prime-counting-func" id="prime-counting-func"></a><a href="computer-algebra2#prime-counting-func-note">prime counting function</a></td>
<td><span style="color: gray">(* 25: *)</span><br />
PrimePi[100]</td>
<td>ntheory.generate.primepi(100)</td>
<td>prime_pi(100)</td>
<td></td>
</tr>
<tr>
<td><a name="divmod" id="divmod"></a><a href="computer-algebra2#divmod-note">divmod</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>QuotientRemainder[7, 3]</td>
<td>divmod(7, 3)</td>
<td>divmod(7, 3)</td>
<td>divide(7, 3);</td>
</tr>
<tr>
<td><a name="gcd" id="gcd"></a><a href="computer-algebra2#gcd-note">greatest common divisor</a><br />
<br />
<span style="color: gray"><em>and relatively prime test</em></span></td>
<td>GCD[14, 21]<br />
GCD[14, 21, 777]<br />
<br />
CoprimeQ[14, 21]</td>
<td>gcd(14, 21)<br />
gcd(gcd(14, 21), 777)</td>
<td>gcd(14, 21)<br />
gcd(gcd(14, 21), 777)</td>
<td>gcd(14, 21);<br />
gcd(gcd(14, 21), 777);</td>
</tr>
<tr>
<td><a name="extended-euclidean-algorithm" id="extended-euclidean-algorithm"></a><a href="computer-algebra2#extended-euclidean-algorithm-note">extended euclidean algorithm</a></td>
<td><span style="color: gray">(* {1, {2, -1}}: *)</span><br />
ExtendedGCD[3, 5]</td>
<td>from sympy.ntheory.modular import igcdex<br />
<br />
<span style="color: gray"># (2, -1, 1):</span><br />
igcdex(3, 5)</td>
<td><span style="color: gray"># (1, 2, -1):</span><br />
xgcd(3, 5)</td>
<td><span style="color: gray">/* [2,-1,1]: */</span><br />
gcdex(3, 5);</td>
</tr>
<tr>
<td><a name="lcm" id="lcm"></a><a href="computer-algebra2#lcm-note">least common multiple</a></td>
<td>LCM[14, 21]</td>
<td>lcm(14, 21)</td>
<td>lcm(14, 21)</td>
<td>lcm(14, 21);</td>
</tr>
<tr>
<td><a name="power-mod" id="power-mod"></a><a href="computer-algebra2#power-mod-note">power modulus</a></td>
<td>PowerMod[3, 212, 7]</td>
<td></td>
<td>power_mod(3, 212, 7)</td>
<td></td>
</tr>
<tr>
<td><a name="mult-inverse" id="mult-inverse"></a><a href="computer-algebra2#mult-inverse-note">multiplicative inverse</a></td>
<td><span style="color: gray">(* inverse of 2 mod 7: *)</span><br />
PowerMod[2, -1, 7]<br />
<br />
<span style="color: gray">(* left unevaluated: *)</span><br />
PowerMod[2, -1, 4]</td>
<td></td>
<td>r = Integers(7)<br />
r(2)^-1<br />
<br />
r2 = Integers(4)<br />
<span style="color: gray"># raises ZeroDivisionError:</span><br />
r2(4)^-1</td>
<td></td>
</tr>
<tr>
<td><a name="chinese-remainder-thm" id="chinese-remainder-thm"></a><a href="computer-algebra2#chinese-remainder-thm-note">chinese remainder theorem</a></td>
<td><span style="color: gray">(* returns 173, which is equal to 3 mod 17 and 8 mod 11: *)</span><br />
ChineseRemainder[{3, 8}, {17, 11}]</td>
<td></td>
<td>crt(3, 8, 17, 11)</td>
<td><span style="color: gray">/* 173: */</span><br />
chinese([3, 8], [17, 11]);</td>
</tr>
<tr>
<td><a name="euler-totient" id="euler-totient"></a><a href="computer-algebra2#euler-totient-note">euler totient</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>EulerPhi[256]</td>
<td>ntheory.totient(256)</td>
<td>euler_phi(256)</td>
<td>totient(256);</td>
</tr>
<tr>
<td><a name="carmichael-func" id="carmichael-func"></a><a href="computer-algebra2#carmichael-func-note">carmichael function</a></td>
<td>CarmichaelLambda[561]</td>
<td></td>
<td>from sage.crypto.util import carmichael_lambda<br />
<br />
carmichael_lambda(561)</td>
<td></td>
</tr>
<tr>
<td><a name="mult-order" id="mult-order"></a><a href="computer-algebra2#mult-order-note">multiplicative order</a></td>
<td>MultiplicativeOrder[7, 108]</td>
<td></td>
<td>Mod(7, 108).multiplicative_order()</td>
<td></td>
</tr>
<tr>
<td><a name="primitive-roots" id="primitive-roots"></a><a href="computer-algebra2#primitive-roots-note">primitive roots</a></td>
<td>PrimitiveRoot[11]<br />
<br />
<span style="color: gray">(* all primitive roots: *)</span><br />
PrimitiveRootList[11]</td>
<td></td>
<td>primitive_root(11)<br />
<br />
<span style="color: gray"># raises ValueError if none</span></td>
<td></td>
</tr>
<tr>
<td><a name="discrete-log" id="discrete-log"></a><a href="computer-algebra2#discrete-log-note">discrete logarithm</a></td>
<td><span style="color: gray">(* solves 10 = 2^x (mod 11): *)</span><br />
MultiplicativeOrder[2, 11, 10]</td>
<td></td>
<td>log(Mod(10, 11), Mod(2, 11))</td>
<td></td>
</tr>
<tr>
<td><a name="quadratic-residues" id="quadratic-residues"></a><a href="computer-algebra2#quadratic-residues-note">quadratic residues</a></td>
<td>Select[Range[0, 4], KroneckerSymbol[#, 5] == 1 &amp;]</td>
<td></td>
<td>quadratic_residues(5)</td>
<td></td>
</tr>
<tr>
<td><a name="discrete-sqrt" id="discrete-sqrt"></a><a href="computer-algebra2#discrete-sqrt-note">discrete square root</a></td>
<td>PowerMod[4, 1/2, 5]</td>
<td></td>
<td>Mod(4, 5).sqrt()</td>
<td></td>
</tr>
<tr>
<td><a name="kronecker-symbol" id="kronecker-symbol"></a><a href="computer-algebra2#kronecker-symbol-note">kronecker symbol</a><br />
<br />
<span style="color: gray"><em>and jacobi symbol</em></span></td>
<td>KroneckerSymbol[3, 5]<br />
JacobiSymbol[3, 5]</td>
<td></td>
<td>kronecker_symbol(3, 5)</td>
<td><span style="color: gray"><em>??</em></span><br />
jacobi(3, 5);</td>
</tr>
<tr>
<td><a name="moebius-func" id="moebius-func"></a><a href="computer-algebra2#moebius-func-note">moebius function</a></td>
<td>MoebiusMu[11]</td>
<td></td>
<td>moebius(11)</td>
<td>moebius(11);</td>
</tr>
<tr>
<td><a name="riemann-zeta-func" id="riemann-zeta-func"></a><a href="computer-algebra2#riemann-zeta-func-note">riemann zeta function</a></td>
<td>Zeta[2]</td>
<td>mpmath.zeta(2)</td>
<td>zeta(2)</td>
<td>zeta(2);</td>
</tr>
<tr>
<td><a name="continued-fraction" id="continued-fraction"></a><a href="computer-algebra2#continued-fraction-note">continued fraction</a></td>
<td><span style="color: gray">(* {0, 1, 1, 1, 5}: *)</span><br />
ContinuedFraction[11/17]<br />
<br />
<span style="color: gray">(* arrray of first 100 digits for for pi: *)</span><br />
ca= ContinuedFraction[Pi, 100]<br />
<br />
<span style="color: gray">(* rational approximation of pi: *)</span><br />
FromContinuedFraction[a]</td>
<td></td>
<td>continued_fraction(11/17)<br />
<br />
continued_fraction(pi, 100)</td>
<td><span style="color: gray">/* [0,1,1,1,5]: */</span><br />
cf(11/17);<br />
<br />
float_pi: %pi, numer;<br />
a = cf(float_pi);<br />
<br />
<span style="color: gray">/* as continued fraction: */</span><br />
as_cf: cfdisrep(a);<br />
<br />
<span style="color: gray">/* as simple fraction: */</span><br />
ratsimp(as_cf);</td>
</tr>
<tr>
<td><a name="convergents" id="convergents"></a><a href="computer-algebra2#convergents-note">convergents</a></td>
<td>Convergents[11/17]<br />
<br />
<span style="color: gray">(* for continued fraction: *)</span><br />
Convergents[{0, 1, 1, 1, 5}]<br />
<br />
<span style="color: gray">(* first 100 rational approximations: *)</span><br />
Convergents[Pi, 100]</td>
<td></td>
<td><span style="color: gray"># [0, 1, 1/2, 2/3, 11/17]:</span><br />
continued_fraction(11/17).convergents()<br />
<br />
<span style="color: gray"># iterable infinite list:</span><br />
continued_fraction(pi, 100).convergents()</td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="polynomials" id="polynomials"></a><a href="computer-algebra2#polynomials-note">polynomials</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="polynomial-literal" id="polynomial-literal"></a><a href="computer-algebra2#polynomial-literal-note">literal</a></td>
<td>p = 2 -3 * x + 2* x^2<br />
p2 = (1 + x)^10</td>
<td></td>
<td>p = x^2 - 3*x + 2<br />
p2 = (x + 1)^10</td>
<td>p: x^2 - 3*x + 2;<br />
p2: (x + 1)^10;</td>
</tr>
<tr>
<td><a name="extract-polynomial-coefficient" id="extract-polynomial-coefficient"></a><a href="computer-algebra2#extract-polynomial-coefficient-note">extract coefficient</a></td>
<td>Coefficient[(1 + x)^10, x, 3]</td>
<td></td>
<td>p = (1 + x)^10<br />
<br />
<span style="color: gray"># coefficients() returns (power, coeff) pairs:</span><br />
[pair[0] for pair in p.coefficients()<br />
<span style="white-space: pre-wrap;"> </span>if pair[1] == 3][0]</td>
<td>coeff(expand((x + 1)^10), x^3);<br />
<br />
coeff(expand((x + 1)^10), x, 3);</td>
</tr>
<tr>
<td><a name="extract-polynomial-coefficients" id="extract-polynomial-coefficients"></a><a href="computer-algebra2#extract-polynomial-coefficients-note">extract coefficients</a></td>
<td>CoefficientList[(x + 1)^10, x]</td>
<td></td>
<td></td>
<td>p: expand((x+1)^10);<br />
makelist(coeff(p, x^i), i, 0, 10);</td>
</tr>
<tr>
<td><a name="polynomial-from-coefficient-array" id="polynomial-from-coefficient-array"></a><a href="computer-algebra2#polynomial-from-coefficient-array-note">from array of coefficients</a></td>
<td>a = {2, -3, 1}<br />
Sum[a[[i]] * x^i, {i, 1, 3}]</td>
<td></td>
<td></td>
<td>a: [2, -3, 1];<br />
sum(x^i * a[i + 1], i, 0, 2);</td>
</tr>
<tr>
<td><a name="polynomial-degree" id="polynomial-degree"></a><a href="computer-algebra2#polynomial-degree-note">degree</a></td>
<td>Exponent[(x + 1)^10, x]</td>
<td></td>
<td></td>
<td>hipow(expand((1 + x)^10), x);</td>
</tr>
<tr>
<td><a name="expand-polynomial" id="expand-polynomial"></a><a href="computer-algebra2#expand-polynomial-note">expand</a></td>
<td>Expand[(1 + x)^5]</td>
<td>expand((1 + x)<span style="white-space: pre-wrap;">**</span>5)</td>
<td>expand((1 + x)^5)</td>
<td>expand((1 + x)^5);</td>
</tr>
<tr>
<td><a name="factor-polynomial" id="factor-polynomial"></a><a href="computer-algebra2#factor-polynomial-note">factor</a></td>
<td>Factor[3 + 10 x + 9 x^2 + 2 x^3]<br />
<br />
Factor[x^10 - y^10]</td>
<td>factor(3 + 10*x + 9*x<span style="white-space: pre-wrap;">**</span>2 + 2*x<span style="white-space: pre-wrap;">**</span>3)</td>
<td>factor(2*x^3 + 9*x^2 + 10*x + 3)</td>
<td>factor(2*x^3 + 9*x^2 + 10*x + 3);</td>
</tr>
<tr>
<td><a name="polynomial-roots" id="polynomial-roots"></a><a href="computer-algebra2#polynomial-roots-note">roots</a></td>
<td>Solve[x^3 + 3 x^2 + 2 x - 1 == 0, x]<br />
<br />
<span style="color: gray">(* just the 2nd root: *)</span><br />
Root[x^3 + 3 x^2 + 2 x - 1, 2]</td>
<td></td>
<td></td>
<td>solve(x^3 + 3*x^2 + 2*x - 1 = 0, x);</td>
</tr>
<tr>
<td><a name="polynomial-quotient-remainder" id="polynomial-quotient-remainder"></a><a href="computer-algebra2#polynomial-quotient-remainder-note">quotient and remainder</a></td>
<td>PolynomialReduce[x^10 - 1, x - 1, {x}]</td>
<td></td>
<td></td>
<td>[q, r]: divide(x^10-1, x - 1);</td>
</tr>
<tr>
<td><a name="polynomial-gcd" id="polynomial-gcd"></a><a href="computer-algebra2#polynomial-gcd-note">greatest common divisor</a></td>
<td>p1 = -2 - x + 2 x^2 + x^3<br />
p2 = 6 - 7 x + x^3<br />
PolynomialGCD[p1, p2]</td>
<td></td>
<td></td>
<td>p1: -2 - x + 2 * x^2 + x^3;<br />
p2: 6 - 7*x + x^3;<br />
gcd(p1, p2);</td>
</tr>
<tr>
<td><a name="polynomial-extended-euclidean-algo" id="polynomial-extended-euclidean-algo"></a><a href="computer-algebra2#polynomial-extended-euclidean-algor-note">extended euclidean algorithm</a></td>
<td>p1 = -2 - x + 2 x^2 + x^3<br />
p2 = 6 - 7 x + x^3<br />
<br />
<span style="color: gray">(* returns list; first element is GCD; 2nd element is list of two polynomials *)</span><br />
PolynomialExtendedGCD[p1, p2, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="resultant" id="resultant"></a><a href="computer-algebra2#resultant-note">resultant</a></td>
<td>Resultant[(x-1) * (x-2), (x-3) * (x-3), x]</td>
<td></td>
<td></td>
<td>resultant((x - 1)*(x - 2), (x - 3)*(x - 3), x);</td>
</tr>
<tr>
<td><a name="discrimant" id="discrimant"></a><a href="computer-algebra2#discriminant-note">discriminant</a></td>
<td>Discriminant[(x + 1) * (x - 2), x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="collect-terms" id="collect-terms"></a><a href="computer-algebra2#collect-terms-note">collect terms</a></td>
<td><span style="color: gray">(* write as polynomial in x: *)</span><br />
Collect[(1 + x + y)^3, x]</td>
<td>collect(expand((x+y+1)**3), x)</td>
<td></td>
<td>load(facexp);<br />
<br />
facsum(expand((1 + x + y)^5), x);</td>
</tr>
<tr>
<td><a name="multivariate-polynomial-quotient-remainder" id="multivariate-polynomial-quotient-remainder"></a><a href="computer-algebra2#multivariate-polynomial-quotient-remainder-note">multivariate quotient and remainder</a></td>
<td>PolynomialReduce[x^10 - y^10, x - y, {x, y}]</td>
<td></td>
<td></td>
<td>[q, r]: divide(x^10 - y^10, x - y);</td>
</tr>
<tr>
<td><a name="groebner-basis" id="groebner-basis"></a><a href="computer-algebra2#groebner-basis-note">groebner basis</a></td>
<td>p1 = x^2 + y + z - 1<br />
p2 = x + y^2 + z - 1<br />
p3 = x + y + z^2 - 1<br />
<br />
<span style="color: gray">(* uses lexographic order by default: *)</span><br />
GroebnerBasis[{p1, p2, p3}, {x, y, z}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>specify ordering</td>
<td>GroebnerBasis[{p1, p2, p3}, {x, y, z},<br />
<span style="white-space: pre-wrap;">  </span>MonomialOrder -&gt; DegreeReverseLexicographic]<br />
<br />
<span style="color: gray">(* possible values for MonomialOrder:<br />
<br />
<span style="white-space: pre-wrap;">   </span>Lexicographic<br />
<span style="white-space: pre-wrap;">   </span>DegreeLexicographic<br />
<span style="white-space: pre-wrap;">   </span>EliminationOrder<br />
<span style="white-space: pre-wrap;">   </span>{1, 2, 3} *)</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>elementary symmetric polynomial</td>
<td>SymmetricPolynomial[3, {x1, x2, x3, x4}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>symmetric reduction</td>
<td><span style="color: gray">(* returns list of two elements; 2nd element is remainder if polynomial not symmetric: *)</span><br />
SymmetricReduction[x^3 + y^3 + z^3, {x, y, z}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="cyclotomic-polynomial" id="cyclotomic-polynomial"></a><a href="computer-algebra2#cyclotomic-polynomial-note">cyclotomic polynomial</a></td>
<td>Cyclotomic[10, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="hermite-polynomial" id="hermite-polynomial"></a><a href="computer-algebra2#hermite-polynomial-note">hermite polynomial</a></td>
<td>HermiteH[4, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="chebyshev-polynomial" id="chebyshev-polynomial"></a><a href="computer-algebra2#chebyshev-polynomial-note">chebyshev polynomial</a><br />
<br />
<span style="color: gray"><em>first and second kind</em></span></td>
<td>ChebyshevT[4, x]<br />
ChebyshevU[4, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>interpolation polynomial</td>
<td>pts = Inner[List, {1, 2, 3}, {2, 4, 7}, List]<br />
InterpolatingPolynomial[pts, x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>spline</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="partial-fraction-decomposition" id="partial-fraction-decomposition"></a><a href="computer-algebra2#partial-fraction-decomposition-note">partial fraction decomposition</a></td>
<td>Apart[(3*x + 2)/ (x^2 + x)]<br />
<br />
<span style="color: gray">(* can handle multiple vars in denominator: *)</span><br />
Apart[(b * c + a * d)/(b * d)]</td>
<td>apart((3*x+2) / (x*(x+1)))</td>
<td></td>
<td>partfrac((3*x + 2) / (x^2 + x), x);</td>
</tr>
<tr>
<td><a name="add-fractions" id="add-fractions"></a><a href="computer-algebra2#add-fractions-note">add fractions</a></td>
<td>Together[a/b + c/d]</td>
<td>together(x/y + z/w)</td>
<td></td>
<td>ratsimp(a/b + c/d);</td>
</tr>
<tr>
<td><a name="pade-approximant" id="pade-approximant"></a><a href="computer-algebra2#pade-approximant-note">pade approximant</a></td>
<td>PadeApproximant[Log[x], {x, 1, {2, 3}}]</td>
<td></td>
<td></td>
<td>p: taylor(log(x + 1), [x, 0, 5]);<br />
<br />
pade(p, 3, 2);</td>
</tr>
<tr>
<th colspan="5"><a name="trigonometry" id="trigonometry"></a><a href="computer-algebra2#trigonometry-note">trigonometry</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="trig-eliminate-powers-products" id="trig-eliminate-powers-products"></a><a href="computer-algebra2#trig-eliminate-powers-products-note">eliminate powers and products of trigonometric functions</a></td>
<td>TrigReduce[Sin[x]^2 + Cos[x] Sin[x]]</td>
<td></td>
<td></td>
<td>trigreduce(sin(x)^2 + cos(x) * sin(x));</td>
</tr>
<tr>
<td><a name="trig-eliminate-sums-multiples" id="trig-eliminate-sums-multiples"></a><a href="computer-algebra2#trig-eliminate-sums-multiples-note">eliminate sums and multiples inside trigonometric functions</a></td>
<td>TrigExpand[Sin[2 * x + 1]]</td>
<td></td>
<td></td>
<td>trigexpand(sin(2*x + 1));</td>
</tr>
<tr>
<td><a name="trig-to-exp" id="trig-to-exp"></a><a href="computer-algebra2#trig-to-exp-note">trigonometric to exponential</a></td>
<td>TrigToExp[Cos[x]]</td>
<td>cos(x).rewrite(cos, exp)</td>
<td></td>
<td>exponentialize(cos(x));</td>
</tr>
<tr>
<td><a name="exp-to-trig" id="exp-to-trig"></a><a href="computer-algebra2#exp-to-trig-note">exponential to trigonometric</a></td>
<td>ExpToTrig[Exp[I x]]</td>
<td>from sympy import exp, sin, I<br />
<br />
exp(I * x).rewrite(exp, sin)</td>
<td></td>
<td>demoivre(exp(%i * x));</td>
</tr>
<tr>
<td><a name="fourier-expansion" id="fourier-expansion"></a><a href="computer-algebra2#fourier-expansion-note">fourier expansion</a></td>
<td><span style="color: gray">(* in sin and cos: *)</span><br />
FourierTrigSeries[SquareWave[x / (2*Pi)],<br />
<span style="white-space: pre-wrap;">  </span>x, 10]<br />
<br />
<span style="color: gray">(* in complex exponentials: *)</span><br />
FourierSeries[SquareWave[x / (2*Pi)], x, 10]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="periodic-func" id="periodic-func"></a><a href="computer-algebra2#periodic-func-note">periodic functions on unit interval</a></td>
<td><span style="color: gray">(*1: [0, 0.5); -1: [0.5, 1.0) *)</span><br />
SquareWave[x]<br />
<br />
<span style="color: gray">(* 0 at 0 and 0.5; 1 at 0.25; -1 at 0.75 *)</span><br />
TriangleWave[x]<br />
<br />
<span style="color: gray">(* x on [0, 1) *)</span><br />
SawtoothWave[x]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="fourier-transform" id="fourier-transform"></a><a href="computer-algebra2#fourier-transform-note">fourier transform</a></td>
<td>f[w_] = FourierTransform[ Sin[t], t, w]<br />
<br />
InverseFourierTransform[f[w], w, t]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="heaviside-step-func" id="heaviside-step-func"></a><a href="computer-algebra2#heaviside-step-func-note">heaviside step function</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="dirac-delta" id="dirac-delta"></a><a href="computer-algebra2#direct-delta-note">dirac delta</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="special-functions" id="special-functions"></a><a href="computer-algebra2#special-functions-note">special functions</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="gamma-func" id="gamma-func"></a><a href="computer-algebra2#gamma-func-note">gamma function</a></td>
<td>Gamma[1/2]</td>
<td>gamma(Rational(1, 2))</td>
<td>gamma(1/2)</td>
<td>gamma(1/2);</td>
</tr>
<tr>
<td><a name="err-func" id="err-func"></a><a href="computer-algebra2#err-func-note">error function</a></td>
<td>Erf[1/2] // N<br />
<br />
Erfc Erfi<br />
InverseErf InverseErfc</td>
<td>N(erf(Rational(1, 2)))<br />
<br />
erfc erfi</td>
<td>n(erf(1/2))</td>
<td>erf(1/2), numer;<br />
<br />
erfc erfi</td>
</tr>
<tr>
<td><a name="hyperbolic-func" id="hyperbolic-func"></a><a href="computer-algebra2#hyperbolic-func-note">hyperbolic functions</a></td>
<td>Sinh Cosh Tanh<br />
ArcSinh ArcCosh ArcTanh</td>
<td>sinh cosh tanh<br />
asinh acosh atanh</td>
<td>sinh cosh tanh<br />
asinh acosh atanh</td>
<td>sinh cosh tanh<br />
asinh acosh atanh</td>
</tr>
<tr>
<td><a name="elliptic-func" id="elliptic-func"></a><a href="computer-algebra2#elliptic-func-note">elliptic integerals</a></td>
<td>EllipticK<br />
EllipticF<br />
EllipticE<br />
EllipticPi</td>
<td></td>
<td></td>
<td>elliptic_f<br />
elliptic_e<br />
elliptic_pi</td>
</tr>
<tr>
<td><a name="bessel-func" id="bessel-func"></a><a href="computer-algebra2#bessel-func-note">bessel functions</a></td>
<td>BesselJ<br />
BesselY<br />
BesselI<br />
BesselK</td>
<td></td>
<td></td>
<td>bessel_j<br />
bessel_y<br />
bessel_i<br />
bessel_k</td>
</tr>
<tr>
<th colspan="5"><a name="permutations" id="permutations"></a><a href="computer-algebra2#permutations-note">permutations</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="permutation-from-disjoint-cycles" id="permutation-from-disjoint-cycles"></a><a href="computer-algebra2#permutation-from-disjoint-cycles-note">from disjoint cycles</a></td>
<td>p = Cycles[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]</td>
<td>import sympy.combinatorics as comb<br />
<br />
p = combinatorics.Permutation(0, 1)(2, 3)</td>
<td>Permutation([(1, 2), (3, 4)])</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-to-disjoint-cycles" id="permutation-to-disjoint-cycles"></a><a href="computer-algebra2#permutation-to-disjoint-cycles-note">to disjoint cycles</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="permutation-from-array" id="permutation-from-array"></a><a href="computer-algebra2#permutation-from-array-note">from array</a></td>
<td>p = PermutationCycles[{2, 1, 4, 3}]</td>
<td>import sympy.combinatorics as comb<br />
<br />
p = combinatorics.Permutation([1, 0, 3, 2])</td>
<td>Permutation((2, 1, 4, 3))</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-from-two-arrays" id="permutation-from-two-arrays"></a><a href="computer-algebra2#permutation-from-two-arrays-note">from two arrays with same elements</a></td>
<td>FindPermutation[{a, b, c}, {b, c, a}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="permutation-size" id="permutation-size"></a><a href="computer-algebra2#permutation-size-note">size</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="permutation-support" id="permutation-support"></a><a href="computer-algebra2#permutation-support-note">support</a><br />
<br />
<span style="color: gray"><em>and fixed points</em></span></td>
<td>PermutationSupport[Cycles[<span style="white-space: pre-wrap;">{{1, 3, 5}, {7, 8}}</span>]]</td>
<td>import sympy.combinatorics as comb<br />
<br />
p = comb.Permutation(0, 2, 4)(6, 7)<br />
p.support()</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="permutation-act-on-element" id="permutation-act-on-element"></a><a href="computer-algebra2#permutation-act-on-element-note">act on element</a></td>
<td>p = Cycles[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]<br />
<br />
PermutationReplace[1, p]</td>
<td>p(0)</td>
<td>Permutation((2, 1, 4, 3))(1)</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-act-on-list" id="permutation-act-on-list"></a><a href="computer-algebra2#permutation-act-on-list-note">act on list</a></td>
<td><span style="color: gray">(* if list is too big, extra elements retain<br />
<span style="white-space: pre-wrap;">   </span>their positions; if list is too small,<br />
<span style="white-space: pre-wrap;">   </span>expression is left unevaluated. *)</span><br />
Permute[{a, b, c, d}, p12n34]</td>
<td>import sympy.combinatorics as comb<br />
<br />
p = comb.Permutation(0, 1)(2, 3)<br />
p([a, b, c, d])</td>
<td>a, b, c, d = var('a b c d')<br />
<br />
p = Permutation([(1, 2), (3, 4)])<br />
p.action([a, b, c, d])</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-compose" id="permutation-compose"></a><a href="computer-algebra2#permutation-compose-note">compose</a></td>
<td>p1 = Cycles[<span style="white-space: pre-wrap;">{{1, 2}, {3, 4}}</span>]<br />
p2 = Cycles[<span style="white-space: pre-wrap;">{{1, 3}}</span>]<br />
PermutationProduct[p1, p2]</td>
<td>import sympy.combinatorics as comb<br />
<br />
p1 = comb.Permutation(0, 1)(2, 3)<br />
p2 = comb.Permutation(0, 2)<br />
p1 * p2</td>
<td>p1 = Permutation([(1, 2), (3, 4)])<br />
p2 = Permutation((1, 3))<br />
p1 * p2</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-inverse" id="permutation-inverse"></a><a href="computer-algebra2#permutation-inverse-note">inverse</a></td>
<td>InversePermutation[Cycles[<span style="white-space: pre-wrap;">{{1, 2, 3}}</span>]]</td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation(0, 1, 2) ** -1</td>
<td>Permutation((1, 2, 3)).inverse()</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-power" id="permutation-power"></a><a href="computer-algebra2#permutation-power-note">power</a></td>
<td>PermutationPower[Cycles[<span style="white-space: pre-wrap;">{{1, 2, 3, 4, 5}}</span>], 3]</td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation(0, 1, 2, 3, 4) ** 3</td>
<td>Permutation((1, 2, 3, 4, 5))^3</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-order" id="permutation-order"></a><a href="computer-algebra2#permutation-order-note">order</a></td>
<td>PermutationOrder[Cycles[<span style="white-space: pre-wrap;">{{1, 2, 3, 4, 5}}</span>]]</td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation(0, 1, 2, 3, 4).order()</td>
<td>p = Permutation((1,2,3,4,5))<br />
p.to_permutation_group_element().order()</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-num-inversions" id="permutation-num-inversions"></a><a href="computer-algebra2#permutation-num-inversions-note">number of inversions</a></td>
<td></td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation(0, 2, 1).inversions()</td>
<td>Permutation((1, 3, 2)).length()</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-parity" id="permutation-parity"></a><a href="computer-algebra2#permutation-parity-note">parity</a></td>
<td></td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation(0, 2, 1).parity()</td>
<td>Permutation((1, 3, 2)).is_even()</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-to-inversion-vec" id="permutation-to-inversion-vec"></a><a href="computer-algebra2#permutation-to-inversion-vec-note">to inversion vector</a></td>
<td></td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation(0, 2, 1).inversion_vector()</td>
<td>Permutation((1, 3, 2)).to_inversion_vector()</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-from-inversion-vec" id="permutation-from-inversion-vec"></a><a href="computer-algebra2#permutation-from-inversion-vec-note">from inversion vector</a></td>
<td></td>
<td>import sympy.combinatorics as comb<br />
<br />
comb.Permutation.from_inversion_vector([2, 0])</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="permutation-list" id="permutation-list"></a><a href="computer-algebra2#permutation-list-note">list permutations</a></td>
<td>GroupElements[SymmetricGroup[4]]<br />
<br />
<span style="color: gray">(* of a list: *)</span><br />
Permutations[{a, b, c, d}]</td>
<td></td>
<td>list(SymmetricGroup(4))</td>
<td></td>
</tr>
<tr>
<td><a name="permutation-random" id="permutation-random"></a><a href="computer-algebra2#permutation-random-note">random permutation</a></td>
<td>RandomPermutation[10]</td>
<td>Permutation.random(10)</td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="descriptive-statistics" id="descriptive-statistics"></a><a href="computer-algebra2#descriptive-statistics-note">descriptive statistics</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="first-moment-stats" id="first-moment-stats"></a><a href="computer-algebra2#first-moment-stats-note">first moment statistics</a></td>
<td>vals = {1, 2, 3, 8, 12, 19}<br />
X = NormalDistribution[0, 1]<br />
<br />
Mean[vals]<br />
Total[vals]<br />
Mean[X]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
<span style="color: gray">/* Other distributions have similar functions: */</span><br />
mean_normal(0, 1);</td>
</tr>
<tr>
<td><a name="second-moment-stats" id="second-moment-stats"></a><a href="computer-algebra2#second-moment-stats-note">second moment statistics</a></td>
<td>Variance[X]<br />
StandardDeviation[X]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
<span style="color: gray">/* Other distributions have similar functions: */</span><br />
var_normal(0, 1);<br />
std_normal(0, 1);</td>
</tr>
<tr>
<td><a name="second-moment-stats-sample" id="second-moment-stats-sample"></a><a href="computer-algebra2#seond-moment-stats-sample-note">second moment statistics for samples</a></td>
<td>Variance[vals]<br />
StandardDeviation[vals]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="skewness" id="skewness"></a><a href="computer-algebra2#skewness-note">skewness</a></td>
<td>Skewness[vals]<br />
Skewness[X]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
<span style="color: gray">/* Other distributions have similar functions: */</span><br />
skewness_normal(0, 1);</td>
</tr>
<tr>
<td><a name="kurtosis" id="kurtosis"></a><a href="computer-algebra2#kurtosis-note">kurtosis</a></td>
<td>Kurtosis[vals]<br />
Kurtosis[X]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
<span style="color: gray">/* Other distributions have similar functions: */</span><br />
kurtosis_normal(0, 1);</td>
</tr>
<tr>
<td><a name="nth-moment" id="nth-moment"></a><a href="computer-algebra2#nth-moment-note">nth moment and nth central moment</a></td>
<td>Moment[vals, 5]<br />
CentralMoment[vals, 5]<br />
Moment[X, 5]<br />
CentralMoment[X, 5]<br />
<br />
MomentGeneratingFunction[X, t]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="cumulant" id="cumulant"></a><a href="computer-algebra2#cumulant-note">cumulant</a></td>
<td>Cumulant[vals, 1]<br />
Cumulant[X, 1]<br />
<br />
CumulantGeneratingFunction[X, t]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="entropy" id="entropy"></a><a href="computer-algebra2#entropy-note">entropy</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Entropy[vals]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="mode" id="mode"></a><a href="computer-algebra2#mode-note">mode</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>Commonest[{1, 2, 2, 2, 3, 3, 8, 12}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="quantile-stats" id="quantile-stats"></a><a href="computer-algebra2#quantile-stats-note">quantile statistics</a></td>
<td>Min[vals]<br />
Median[vals]<br />
Max[vals]<br />
InterquartileRange[vals]<br />
Quantile[vals, 9/10]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
<span style="color: gray">/* Other distributions have similar functions: */</span><br />
quantile_normal(9/10, 0, 1);</td>
</tr>
<tr>
<td><a name="bivariate-stats" id="bivariate-stats"></a><a href="computer-algebra2#bivariate-stats-note">bivariate statistiscs</a><br />
<span style="color: gray"><em>correlation, covariance, Spearman's rank</em></span></td>
<td>Correlation[{1, 2, 3}, {2, 4, 7}]<br />
Covariance[{1, 2, 3}, {2, 4, 7}]<br />
SpearmanRho[{1, 2, 3}, {2, 4, 7}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="freq-table" id="freq-table"></a><a href="computer-algebra2#freq-table-note">data set to frequency table</a></td>
<td>data = {1, 2, 2, 2, 3, 3, 8, 12}<br />
<span style="color: gray">(* list of pairs: *)</span><br />
tab = Tally[data]<br />
<span style="color: gray">(* dictionary: *)</span><br />
dict = Counts[data]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="invert-freq-table" id="invert-freq-table"></a><a href="computer-algebra2#invert-freq-table-note">frequency table to data set</a></td>
<td>f = Function[a, Table[a[[1]], {i, 1, a[[2]]}]]<br />
data = Flatten[Map[f, tab]]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="bin" id="bin"></a><a href="computer-algebra2#bin-note">bin</a></td>
<td>data = {1.1, 3.7, 8.9, 1.2, 1.9, 4.1}<br />
<span style="color: gray">(* bins are [0, 3), [3, 6), and [6, 9): *)</span><br />
bins = BinCounts[data, <tt>0, 3, 6, 9</tt>]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="distributions" id="distributions"></a><a href="computer-algebra2#distributions-note">distributions</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="binomial" id="binomial"></a><a href="computer-algebra2#binomial-note">binomial</a><br />
<br />
<span style="color: gray"><em>density, cumulative distribution, sample</em></span></td>
<td>X = BinomialDistribution[100, 1/2]<br />
<br />
PDF[X][50]<br />
CDF[X][50]<br />
RandomVariate[X]</td>
<td>from sympy.stats import *<br />
<br />
X = Binomial('X', 100, Rational(1, 2))<br />
<br />
density(Y).dict[Integer(50)]<br />
P(X &lt; 50)<br />
sample(X)</td>
<td></td>
<td>load(distrib);<br />
<br />
pdf_binomial(x, 50, 1/2);<br />
cdf_binomial(x, 50, 1/2);<br />
random_binomial(50, 1/2);</td>
</tr>
<tr>
<td><a name="poisson" id="poisson"></a><a href="computer-algebra2#poisson-note">poisson</a></td>
<td>X = PoissonDistribution[1]</td>
<td><span style="color: gray"># P(X &lt; 4) raises NotImplementedError:</span><br />
X = Poisson('X', 1)</td>
<td></td>
<td>load(distrib);<br />
<br />
pdf_poisson(x, 1);<br />
cdf_poisson(x, 1);<br />
random_poisson(1);</td>
</tr>
<tr>
<td><a name="discrete-uniform" id="discrete-uniform"></a><a href="computer-algebra2#discrete-uniform-note">discrete uniform</a></td>
<td>X = DiscreteUniformDistribution[{0, 99}]</td>
<td>X = DiscreteUniform('X', list(range(0, 100)))</td>
<td></td>
<td>load(distrib);<br />
<br />
<span style="color: gray">/* {1, 2, …, 100}: */</span><br />
pdf_discrete_uniform(x, 100);<br />
cdf_discrete_uniform(x, 100);<br />
random_discrete_uniform(100);</td>
</tr>
<tr>
<td><a name="normal" id="normal"></a><a href="computer-algebra2#normal-note">normal</a><br />
<br />
<span style="color: gray"><em>density, cumulative distribution, quantile, sample</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
<br />
PDF[X][0]<br />
CDF[X][0]<br />
InverseFunction[CDF[X]][1/2]<br />
RandomVariate[X, 10]</td>
<td>from sympy.stats import *<br />
<br />
X = Normal('X', 0, 1)<br />
<br />
density(X)(0)<br />
P(X &lt; 0)<br />
<span style="color: gray"><em>??</em></span><br />
sample(X)</td>
<td>X = RealDistribution('gaussian', 1)<br />
<br />
X.distribution_function(0)<br />
X.cum_distribution_function(0)<br />
X.cum_distribution_function_inv(0.5)<br />
X.get_random_element()</td>
<td>with(distrib);<br />
<br />
pdf_normal(x, 0, 1);<br />
cdf_normal(x, 0, 1);<br />
<span style="color: gray">/* no inverse cdf */</span><br />
random_normal(0, 1);</td>
</tr>
<tr>
<td><a name="gamma" id="gamma"></a><a href="computer-algebra2#gamma-note">gamma</a></td>
<td>X = GammaDistribution[1, 1]</td>
<td>X = Gamma('X', 1, 1)</td>
<td></td>
<td>with(distrib);<br />
<br />
pdf_gamma(x, 1, 1);<br />
cdf_gamma(x, 1, 1);<br />
random_gamma(1, 1);</td>
</tr>
<tr>
<td><a name="exponential" id="exponential"></a><a href="computer-algebra2#exponential-note">exponential</a></td>
<td>X = ExponentialDistribution[1]</td>
<td>X = Exponential('X', 1)</td>
<td></td>
<td>with(distrib);<br />
<br />
pdf_exponential(x, );<br />
cdf_exponential(x, 1);<br />
random_exponential(1);</td>
</tr>
<tr>
<td><a name="chi-squared" id="chi-squared"></a><a href="computer-algebra2#chi-squared-note">chi-squared</a></td>
<td>X = ChiSquareDistribution[2]</td>
<td>X = ChiSquared('X', 2)</td>
<td>X = RealDistribution('chisquared', 2)</td>
<td>with(distrib);<br />
<br />
pdf_chi2(x, 2);<br />
cdf_chi2(x, 2);<br />
random_chi2(2);</td>
</tr>
<tr>
<td><a name="beta" id="beta"></a><a href="computer-algebra2#beta-note">beta</a></td>
<td>X = BetaDistribution[10, 90]</td>
<td>X = Beta('X', 10, 90)</td>
<td>X = RealDistribution('beta', [10, 90])</td>
<td>with(distrib);<br />
<br />
pdf_beta(x, 10, 90);<br />
cdf_beta(x, 10, 90);<br />
random_beta(10, 90);</td>
</tr>
<tr>
<td><a name="uniform" id="uniform"></a><a href="computer-algebra2#uniform-note">uniform</a></td>
<td>X = UniformDistribution[{0, 1}]</td>
<td>X = Uniform('X', 0, 1)</td>
<td>X = RealDistribution('uniform', [0, 1])<br />
<br />
X.distribution_function(0.5)<br />
X.cum_distribution_function(0.5)<br />
X.cum_distribution_function_inv(0.5)<br />
X.get_random_element()</td>
<td>with(distrib);<br />
<br />
pdf_continuous_uniform(x, 0, 1);<br />
cdf_continuous_uniform(x, 0, 1);<br />
random_continuous_uniform(0, 1);</td>
</tr>
<tr>
<td><a name="students-t" id="students-t"></a><a href="computer-algebra2#students-t-note">student's t</a></td>
<td>X = StudentTDistribution[2]</td>
<td>X = StudentT('X', 2)</td>
<td>X = RealDistribution('t', 2)</td>
<td>with(distrib);<br />
<br />
pdf_student_t(x, 2);<br />
cdf_student_t(x, 2);<br />
random_student_t(2);</td>
</tr>
<tr>
<td><a name="snedecors-f" id="snedecors-f"></a><a href="computer-algebra2#snedecors-f-note">snedecor's F</a></td>
<td>X = FRatioDistribution[1, 1]</td>
<td>X = FDistribution('X', 1, 1)</td>
<td>X = RealDistribution('F', [1, 1])</td>
<td>with(distrib);<br />
<br />
pdf_f(x, 1, 1);<br />
cdf_f(x, 1, 1);<br />
random_f(1, 1);</td>
</tr>
<tr>
<td><a name="empirical-density-func" id="empirical-density-func"></a><a href="computer-algebra2#empirical-density-func-note">empirical density function</a></td>
<td>X = NormalDistribution[0, 1]<br />
data = Table[RandomVariate[X], {i, 1, 30}]<br />
Y = EmpiricalDistribution[data]<br />
PDF[Y]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="empirical-cumulative-distribution" id="empirical-cumulative-distribution"></a><a href="computer-algebra2#empirical-cumulative-distribution-note">empirical cumulative distribution</a></td>
<td>X = NormalDistribution[0, 1]<br />
data = Table[RandomVariate[X], {i, 1, 30}]<br />
Y = EmpiricalDistribution[data]<br />
Plot[CDF[Y][x], {x, -4, 4}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="statistical-tests" id="statistical-tests"></a><a href="computer-algebra2#statistical-tests-note">statistical tests</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="wilcoxon" id="wilcoxon"></a><a href="computer-algebra2#wilcoxon-note">wilcoxon signed-rank test</a><br />
<span style="color: gray"><em>variable is symmetric around zero</em></span></td>
<td>X = UniformDistribution[{-1/2, 1/2}]<br />
data = RandomVariate[X, 100]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
SignedRankTest[data]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
SignedRankTest[data + 1/2]</td>
<td></td>
<td></td>
<td>load(distrib); load(stats);<br />
<br />
data: makelist(<br />
<span style="white-space: pre-wrap;">  </span>random_continuous_uniform(-1/2, 1/2),<br />
<span style="white-space: pre-wrap;">  </span>i, 1, 100);<br />
<br />
<span style="color: gray">/* null hypothesis is true: */</span><br />
test_signed_rank(data);<br />
<br />
<span style="color: gray">/* alternative hypothesis is true: */</span><br />
test_signed_rank(data + 1/2);</td>
</tr>
<tr>
<td><a name="kruskal" id="kruskal"></a><a href="computer-algebra2#kruskal-note">kruskal-wallis rank sum test</a><br />
<span style="color: gray"><em>variables have same location parameter</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
Y = UniformDistribution[{0, 1}]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
LocationEquivalenceTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[X, 200]}]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
LocationEquivalenceTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[Y, 200]}]</td>
<td></td>
<td></td>
<td>load(distrib); load(stats);<br />
<br />
x1: makelist(<br />
<span style="white-space: pre-wrap;">  </span>random_normal(0, 1),<br />
<span style="white-space: pre-wrap;">  </span>i, 1, 100);<br />
x2: makelist(<br />
<span style="white-space: pre-wrap;">  </span>random_normal(0, 1),<br />
<span style="white-space: pre-wrap;">  </span>i, 1, 100);<br />
y: makelist(<br />
<span style="white-space: pre-wrap;">  </span>random_continuous_uniform(-1/2, 1/2),<br />
<span style="white-space: pre-wrap;">  </span>i, 1, 100);<br />
<br />
<span style="color: gray">/* null hypothesis is true: */</span><br />
test_rank_sum(x1, x2);<br />
<br />
<span style="color: gray">/* alternative hypothesis is true: */</span><br />
test_rank_sum(x1, y);</td>
</tr>
<tr>
<td><a name="kolmogorov-smirnov-test" id="kolmogorov-smirnov-test"></a><a href="computer-algebra2#kolmogorov-smirnov-test-note">kolmogorov-smirnov test</a><br />
<span style="color: gray"><em>variables have same distribution</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
Y = UniformDistribution[{-1/2, 1/2}]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
KolmogorovSmirnovTest[RandomVariate[X, 200], X]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
KolmogorovSmirnovTest[RandomVariate[X, 200], Y]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="one-sample-t-test" id="one-sample-t-test"></a><a href="computer-algebra2#one-sample-t-test-note">one-sample t-test</a><br />
<span style="color: gray"><em>mean of normal variable with unknown variance is zero</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
TTest[RandomVariate[X, 200]]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
TTest[RandomVariate[X, 200] + 1]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="independent-two-sample-t-test" id="independent-two-sample-t-test"></a><a href="computer-algebra2#independent-two-sample-t-test-note">independent two-sample t-test</a><br />
<span style="color: gray"><em>two normal variables have same mean</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
TTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[X, 200]}]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
TTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[X, 100] + 1}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="paired-sample-t-test" id="paired-sample-t-test"></a><a href="computer-algebra2#paired-sample-t-test-note">paired sample t-test</a><br />
<span style="color: gray"><em>population has same mean across measurements</em></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="one-sample-binomial-test" id="one-sample-binomial-test"></a><a href="computer-algebra2#one-sample-binomial-test-note">one-sample binomial test</a><br />
<span style="color: gray"><em>binomial variable parameter are as given</em></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="two-sample-binomial-test" id="two-sample-binomial-test"></a><a href="computer-algebra2#two-sample-binomial-test-note">two-sample binomial test</a><br />
<span style="color: gray"><em>parameters of two binomial variables are equal</em></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="chi-squared-test" id="chi-squared-test"></a><a href="computer-algebra2#chi-squared-test-note">chi-squared test</a><br />
<span style="color: gray"><em>parameters of multinomial variable are all equal</em></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="poisson-test" id="poisson-test"></a><a href="computer-algebra2#poisson-test-note">poisson test</a><br />
<span style="color: gray"><em>parameter of poisson variable is as given</em></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="f-test" id="f-test"></a><a href="computer-algebra2#f-test-note">F test</a><br />
<span style="color: gray"><em>ratio of variance of normal variables are the same</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
Y = NormalDistribution[0, 2]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
FisherRatioTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[X, 200]}]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
FisherRatioTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[Y, 100]}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="pearson-product-moment-test" id="pearson-product-moment-test"></a><a href="computer-algebra2#pearson-product-moment-test-note">pearson product moment test</a><br />
<span style="color: gray"><em>normal variables are not correlated</em></span></td>
<td>X = NormalDistrubtion[0, 1]<br />
x = RandomVariate[X, 100]<br />
y = RandomVariate[X, 100]<br />
x2 = x + RandomVariate[X, 100]<br />
data1 = Inner[List, x, y, List]<br />
data2 = Inner[List, x, x2, List]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
CorrelationTest[data1, 0, "PearsonCorrelation"]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
CorrelationTest[data2, 0, "PearsonCorrelation"]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="spearman-rank-test" id="spearman-rank-test"></a><a href="computer-algebra2#spearman-rank-test-note">spearman rank test</a><br />
<span style="color: gray"><em>variables are not correlated</em></span></td>
<td>X = UniformDistribution[{0, 1}]<br />
x = RandomVariate[X, 100]<br />
y = RandomVariate[X, 100]<br />
x2 = x + RandomVariate[X, 100]<br />
data1 = Inner[List, x, y, List]<br />
data2 = Inner[List, x, x2, List]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
CorrelationTest[data1, 0, "SpearmanRank"]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
CorrelationTest[data2, 0, "SpearmanRank"]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="shapiro-wilk-test" id="shapiro-wilk-test"></a><a href="computer-algebra2#shapiro-wilk-test-note">shapiro-wilk test</a><br />
<span style="color: gray"><em>variable has normal distribution</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
Y = UniformDistribution[{0, 1}]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
ShapiroWilkTest[RandomVariate[X, 100]]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
ShapiroWilkTest[RandomVariate[Y, 100]]</td>
<td></td>
<td></td>
<td>load(distrib); load(stats);<br />
<br />
x: makelist(<br />
<span style="white-space: pre-wrap;">  </span>random_normal(0, 1),<br />
<span style="white-space: pre-wrap;">  </span>i, 1, 100);<br />
y: makelist(<br />
<span style="white-space: pre-wrap;">  </span>random_continuous_uniform(-1/2, 1/2),<br />
<span style="white-space: pre-wrap;">  </span>i, 1, 100);<br />
<br />
<span style="color: gray">/* null hypothesis is true: */</span><br />
test_normality(x);<br />
<br />
<span style="color: gray">/* alternative hypothesis is true: */</span><br />
test_normality(y);</td>
</tr>
<tr>
<td><a name="bartletts-test" id="bartletts-test"></a><a href="computer-algebra2#bartletts-test-note">bartlett's test</a><br />
<span style="color: gray"><em>two or more normal variables have same variance</em></span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="levene-test" id="levene-test"></a><a href="computer-algebra2#levene-test-note">levene's test</a><br />
<span style="color: gray"><em>two or more variables have same variance</em></span></td>
<td>X = NormalDistribution[0, 1]<br />
Y = NormalDistribution[0, 2]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
LeveneTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[X, 200]}]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
LeveneTest[<br />
<span style="white-space: pre-wrap;">  </span>{RandomVariate[X, 100],<br />
<span style="white-space: pre-wrap;">   </span>RandomVariate[Y, 100]}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="one-way-anova" id="one-way-anova"></a><a href="computer-algebra2#one-way-anova-note">one-way anova</a><br />
<span style="color: gray"><em>two or more normal variables have same mean</em></span></td>
<td>Needs["ANOVA‘"]<br />
<br />
X = NormalDistribution[0, 1]<br />
ones = Table[1, {i, 1, 100}]<br />
x1 = Inner[<br />
<span style="white-space: pre-wrap;">  </span>List, ones, RandomVariate[X, 100], List]<br />
x2 = Inner[<br />
<span style="white-space: pre-wrap;">  </span>List, 2 * ones, RandomVariate[X, 100], List]<br />
x3 = Inner[<br />
<span style="white-space: pre-wrap;">  </span>List, 3 * ones, RandomVariate[X, 100], List]<br />
y = Inner[<br />
<span style="white-space: pre-wrap;">  </span>List,<br />
<span style="white-space: pre-wrap;">  </span>3 * ones,<br />
<span style="white-space: pre-wrap;">  </span>RandomVariate[X, 100] + 0.5,<br />
<span style="white-space: pre-wrap;">  </span>List]<br />
<br />
<span style="color: gray">(* null hypothesis is true: *)</span><br />
ANOVA[Join[x1, x2, x3]]<br />
<br />
<span style="color: gray">(* alternative hypothesis is true: *)</span><br />
ANOVA[Join[x1, x2, y]]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="two-way-anova" id="two-way-anova"></a><a href="computer-algebra2#two-way-anova-note">two-way anova</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="bar-charts" id="bar-charts"></a><a href="computer-algebra2#bar-charts-note">bar charts</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="vertical-bar-chart" id="vertical-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/vertical-bar-chart.jpg" alt="vertical-bar-chart.jpg" class="image" /><br />
<a href="computer-algebra2#vertical-bar-chart-note">vertical bar chart</a></td>
<td>BarChart[{7, 3, 8, 5, 5},<br />
<span style="white-space: pre-wrap;">  </span>ChartLegends-&gt;<br />
<span style="white-space: pre-wrap;">    </span>{"a","b","c","d","e"}]</td>
<td></td>
<td></td>
<td>x: [7, 3, 8, 5, 5];<br />
labs: [a, b, c, d, e];<br />
data: makelist(makelist(labs[i], j, x[i]), i, 5);<br />
wxbarsplot(flatten(data));</td>
</tr>
<tr>
<td><a name="horizontal-bar-chart" id="horizontal-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/horizontal-bar-chart.jpg" alt="horizontal-bar-chart.jpg" class="image" /><br />
<a href="computer-algebra2#horizontal-bar-chart-note">horizontal bar chart</a></td>
<td>BarChart[{7, 3, 8, 5, 5}, BarOrigin -&gt; Left]</td>
<td></td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="grouped-bar-chart" id="grouped-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/grouped-bar-chart.jpg" alt="grouped-bar-chart.jpg" class="image" /><br />
<a href="computer-algebra2#grouped-bar-chart-note">grouped bar chart</a></td>
<td>data = <span style="white-space: pre-wrap;">{{</span>7, 1}, {3, 2}, {8, 1}, {5, 3}, {5, 1<span style="white-space: pre-wrap;">}}</span><br />
BarChart[data]</td>
<td></td>
<td></td>
<td>x: [7, 3, 8, 5, 5];<br />
y: [1,2,1,3,1];<br />
labs: [a, b, c, d, e];<br />
d1: makelist(makelist(labs[i], j, x[i]), i, 5);<br />
d2: makelist(makelist(labs[i], j, y[i]), i, 5);<br />
wxbarsplot(flatten(d1), flatten(d2));</td>
</tr>
<tr>
<td><a name="stacked-bar-chart" id="stacked-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/stacked-bar-chart.jpg" alt="stacked-bar-chart.jpg" class="image" /><br />
<a href="computer-algebra2#stacked-bar-chart-note">stacked bar chart</a></td>
<td>data = <span style="white-space: pre-wrap;">{{</span>7, 1}, {3, 2}, {8, 1}, {5, 3}, {5, 1<span style="white-space: pre-wrap;">}}</span><br />
BarChart[data, ChartLayout -&gt; "Stacked"]</td>
<td></td>
<td></td>
<td>x: [7, 3, 8, 5, 5];<br />
y: [1,2,1,3,1];<br />
labs: [a, b, c, d, e];<br />
d1: makelist(makelist(labs[i], j, x[i]), i, 5);<br />
d2: makelist(makelist(labs[i], j, y[i]), i, 5);<br />
wxbarsplot(flatten(d1), flatten(d2),<br />
<span style="white-space: pre-wrap;">  </span>grouping=stacked);</td>
</tr>
<tr>
<td><a name="pie-chart" id="pie-chart"></a><img src="http://cdn.hyperpolyglot.org/images/pie-chart.jpg" alt="pie-chart.jpg" class="image" /><br />
<a href="computer-algebra2#pie-chart-note">pie chart</a></td>
<td>PieChart[{7, 3, 8, 5, 5}]</td>
<td></td>
<td></td>
<td>x: [7, 3, 8, 5, 5];<br />
labs: [a, b, c, d, e];<br />
data: makelist(makelist(labs[i], j, x[i]), i, 5);<br />
wxpiechart(flatten(data));</td>
</tr>
<tr>
<td><a name="histogram" id="histogram"></a><img src="http://cdn.hyperpolyglot.org/images/histogram.jpg" alt="histogram.jpg" class="image" /><br />
<a href="computer-algebra2#histogram-note">histogram</a></td>
<td>X = NormalDistribution[0, 1]<br />
<span style="color: gray">(* 2nd arg is approx number of bins: *)</span><br />
Histogram[RandomReal[X, 100], 10]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
data: makelist(random_normal(0, 1), i, 1, 100);<br />
wxhistogram(data);</td>
</tr>
<tr>
<td><a name="box-plot" id="box-plot"></a><img src="http://cdn.hyperpolyglot.org/images/box-plot.jpg" alt="box-plot.jpg" class="image" /><br />
<a href="computer-algebra2#box-plot-note">box plot</a></td>
<td>X = NormalDistribution[0, 1]<br />
n100 = RandomVariate[X, 100]<br />
BoxWhiskerChart[n100]<br />
<br />
Y = ExponentialDistribution[1]<br />
e100 = RandomVariate[Y, 100]<br />
u100 = RandomReal[1, 100]<br />
data = {n100, e100, u100}<br />
BoxWhiskerChart[data]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
data: makelist(random_normal(0, 1), i, 1, 100);<br />
wxboxplot(data);</td>
</tr>
<tr>
<th colspan="5"><a name="scatter-plots" id="scatter-plots"></a><a href="computer-algebra2#scatter-plots-note">scatter plots</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="strip-chart" id="strip-chart"></a><img src="http://cdn.hyperpolyglot.org/images/strip-chart.jpg" alt="strip-chart.jpg" class="image" /><br />
<a href="computer-algebra2#strip-chart-note">strip chart</a></td>
<td>X = NormalDistribution[0, 1]<br />
data = {RandomReal[X], 0} &amp; /@ Range[1, 50]<br />
ListPlot[data]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="strip-chart-jitter" id="strip-chart-jitter"></a><img src="http://cdn.hyperpolyglot.org/images/strip-chart-jitter.jpg" alt="strip-chart-jitter.jpg" class="image" /><br />
<a href="computer-algebra2#strip-chart-jitter-note">strip chart with jitter</a></td>
<td>X = NormalDistribution[0, 1]<br />
Y = UniformDistribution[{-0.05, 0.05}]<br />
data = {RandomReal[X], RandomReal[Y]} &amp; /@<br />
<span style="white-space: pre-wrap;">  </span>Range[1, 50]<br />
ListPlot[data,<br />
<span style="white-space: pre-wrap;">  </span>PlotRange -&gt; {Automatic, {-1, 1}}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="scatter-plot" id="scatter-plot"></a><img src="http://cdn.hyperpolyglot.org/images/scatter-plot.jpg" alt="scatter-plot.jpg" class="image" /><br />
<a href="computer-algebra2#scatter-plot-note">scatter plot</a></td>
<td>X = NormalDistribution[0, 1]<br />
rand = Function[RandomReal[X]]<br />
data = {rand[], rand[]} &amp; /@ Range[1, 50]<br />
ListPlot[data]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x: makelist(random_normal(0, 1), i, 1, 50);<br />
y: makelist(random_normal(0, 1), i, 1, 50);<br />
wxplot2d([discrete, x, y], [style, points]);</td>
</tr>
<tr>
<td><a name="additional-point-set" id="additional-point-set"></a><img src="http://cdn.hyperpolyglot.org/images/additional-point-set.jpg" alt="additional-point-set.jpg" class="image" /><br />
<a href="computer-algebra2#additional-point-set-note">additional point set</a></td>
<td>X = NormalDistribution[0, 1]<br />
rand = Function[RandomReal[X]]<br />
data1 = {rand[], rand[]} &amp; /@ Range[1, 50]<br />
data2 = {rand[]+1, rand[]+1} &amp; /@ Range[1, 50]<br />
Show[ListPlot[data1],<br />
<span style="white-space: pre-wrap;">  </span>ListPlot[data2, PlotStyle -&gt; Red]]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x1: makelist(random_normal(0, 1), i, 1, 50);<br />
y1: makelist(random_normal(0, 1), i, 1, 50);<br />
x2: makelist(random_normal(0, 1), i, 1, 50) + 1;<br />
y2: makelist(random_normal(0, 1), i, 1, 50); + 1;<br />
wxplot2d([[discrete, x1, y1],<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>[discrete, x2, y2]],<br />
<span style="white-space: pre-wrap;">  </span>[style, points], [color, black, red]);</td>
</tr>
<tr>
<td><a name="point-types" id="point-types"></a><a href="computer-algebra2#point-types-note">point types</a></td>
<td>ListPlot[data, PlotMarkers -&gt; {"*"}]<br />
<br />
<span style="color: gray">(* shows standard sequence of point types: *)</span><br />
Graphics`PlotMarkers[]<br />
<br />
<span style="color: gray">(* The elements of the PlotMarkers array can be strings, symbols, expressions, or images. *)</span></td>
<td></td>
<td></td>
<td>wxplot2d([discrete, x, y],<br />
<span style="white-space: pre-wrap;">  </span>[style, points],<br />
<span style="white-space: pre-wrap;">  </span>[point_type, asterisk]);<br />
<br />
<span style="color: gray">/* possible point_type values:<br />
<br />
<span style="white-space: pre-wrap;">  </span>asterisk<br />
<span style="white-space: pre-wrap;">  </span>box<br />
<span style="white-space: pre-wrap;">  </span>bullet<br />
<span style="white-space: pre-wrap;">  </span>circle<br />
<span style="white-space: pre-wrap;">  </span>diamond<br />
<span style="white-space: pre-wrap;">  </span>plus<br />
<span style="white-space: pre-wrap;">  </span>square<br />
<span style="white-space: pre-wrap;">  </span>times<br />
<span style="white-space: pre-wrap;">  </span>triangle<br />
<br />
The bullet and box are filled versions of circle and square.<br />
*/</span></td>
</tr>
<tr>
<td><a name="point-size" id="point-size"></a><a href="computer-algebra2#point-size-note">point size</a></td>
<td>X = NormalDistribution[0, 1]<br />
rand = Function[RandomReal[X]]<br />
data = {rand[], rand[]} &amp; /@ Range[1, 50]<br />
<span style="color: gray">(* point size is fraction of plot width: *)</span><br />
ListPlot[data, PlotStyle -&gt; {PointSize[0.03]}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="scatter-plot-matrix" id="scatter-plot-matrix"></a><img src="http://cdn.hyperpolyglot.org/images/scatter-plot-matrix.jpg" alt="scatter-plot-matrix.jpg" class="image" /><br />
<a href="computer-algebra2#scatter-plot-matrix-note">scatter plot matrix</a></td>
<td>Needs["StatisticalPlots<span style="white-space: pre-wrap;">`</span>"]<br />
<br />
X = NormalDistribution[0, 1]<br />
x = RandomReal[X, 50]<br />
y = RandomReal[X, 50]<br />
z = x + 3 * y<br />
w = y + RandomReal[X, 50]<br />
PairwiseScatterPlot[Transpose[{x, y, z, w}]]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x: makelist(random_normal(0, 1), i, 1, 50);<br />
y: makelist(random_normal(0, 1), i, 1, 50);<br />
z: x + 3 * y;<br />
w: y + makelist(random_normal(0, 1), i, 1, 50);<br />
wxscatterplot(transpose(matrix(x, y, z, w)));</td>
</tr>
<tr>
<td><a name="scatter-plot-3d" id="scatter-plot-3d"></a><img src="http://cdn.hyperpolyglot.org/images/scatter-plot-3d.jpg" alt="scatter-plot-3d.jpg" class="image" /><br />
<a href="computer-algebra2#scatter-plot-3d-note">3d scatter plot</a></td>
<td>X = NormalDistribution[0, 1]<br />
data = RandomReal[X, {50, 3}]<br />
ListPointPlot3D[data]</td>
<td></td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="bubble-chart" id="bubble-chart"></a><img src="http://cdn.hyperpolyglot.org/images/bubble-chart.jpg" alt="bubble-chart.jpg" class="image" /><br />
<a href="computer-algebra2#bubble-chart-note">bubble chart</a></td>
<td>X = NormalDistribution[0, 1]<br />
data = RandomReal[X, {50, 3}]<br />
BubbleChart[data]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="linear-regression-line" id="linear-regression-line"></a><img src="http://cdn.hyperpolyglot.org/images/linear-regression-line.jpg" alt="linear-regression-line.jpg" class="image" /><br />
<a href="computer-algebra2#linear-regression-line-note">linear regression line</a></td>
<td>data = Table[{i, 2 * i + RandomReal[{-5, 5}]},<br />
<span style="white-space: pre-wrap;">  </span>{i, 0, 20}]<br />
model = LinearModelFit[data, x, x]<br />
Show[ListPlot[data],<br />
<span style="white-space: pre-wrap;">  </span>Plot[model["BestFit"],<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>{x, 0, 20}]]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
load(lsquares);<br />
<br />
X: makelist(i, i, 50);<br />
Y: makelist(X[i] + random_normal(0, 1), i, 50);<br />
M: transpose(matrix(X, Y));<br />
fit: lsquares_estimates(M, [x, y], y = A*x + B,<br />
<span style="white-space: pre-wrap;">  </span>[A, B]);<br />
A: second(fit[1][1]), numer;<br />
B: second(fit[1][2]), numer;<br />
Xhat: makelist(A*X[i] + B, i, 50);<br />
wxplot2d([[discrete, X, Y], [discrete, X, Xhat]],<br />
<span style="white-space: pre-wrap;">  </span>[style, points, lines], [color, black, red]);</td>
</tr>
<tr>
<td><a name="q-q-plot" id="q-q-plot"></a><img src="http://cdn.hyperpolyglot.org/images/q-q-plot.jpg" alt="q-q-plot.jpg" class="image" /><br />
<a href="computer-algebra2#q-q-plot-note">quantile-quantile plot</a></td>
<td>X = NormalDistribution[0, 1]<br />
data1 = RandomReal[1, 50]<br />
data2 = RandomReal[X, 50]<br />
QuantilePlot[data1, data2]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x: makelist(random_continuous_uniform(0, 1),<br />
<span style="white-space: pre-wrap;">  </span>i, 200);<br />
y: makelist(random_normal(0, 1), i, 200);<br />
wxplot2d([discrete, sort(x), sort(y)],<br />
<span style="white-space: pre-wrap;">  </span>[style, points]);</td>
</tr>
<tr>
<th colspan="5"><a name="line-charts" id="line-charts"></a><a href="computer-algebra2#line-charts-note">line charts</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="polygonal-line-plot" id="polygonal-line-plot"></a><img src="http://cdn.hyperpolyglot.org/images/polygonal-line-plot.jpg" alt="polygonal-line-plot.jpg" class="image" /><br />
<a href="computer-algebra2#polygonal-line-plot-note">polygonal line plot</a></td>
<td>X = NormalDistribution[0, 1]<br />
rand = Function[RandomReal[X]]<br />
f = Function[i, {i, rand[]}]<br />
data = f /@ Range[1, 20]<br />
ListLinePlot[data]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x: makelist(random_normal(0, 1), i, 1, 20);<br />
wxplot2d([discrete, makelist(i, i, 20), x]);</td>
</tr>
<tr>
<td><a name="additional-line" id="additional-line"></a><img src="http://cdn.hyperpolyglot.org/images/additional-line.jpg" alt="additional-line.jpg" class="image" /><br />
<a href="computer-algebra2#additional-line-note">additional line</a></td>
<td>X = NormalDistribution[0, 1]<br />
data1 = RandomReal[X, 20]<br />
data2 = RandomReal[X, 20]<br />
ListLinePlot[{data1, data2}<br />
<span style="white-space: pre-wrap;">  </span>PlotStyle-&gt;{Black, Red}]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x: makelist(random_normal(0, 1), i, 1, 20);<br />
y: makelist(random_normal(0, 1), i, 1, 20);<br />
wxplot2d([[discrete, makelist(i, i, 20), x],<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>[discrete, makelist(i, i, 20), y]],<br />
<span style="white-space: pre-wrap;">  </span>[color, black, red]);</td>
</tr>
<tr>
<td><a name="line-types" id="line-types"></a><a href="computer-algebra2#line-types-note">line types</a></td>
<td>ListLinePlot[data, PlotStyle -&gt; Dashed]<br />
<br />
<span style="color: gray">(* PlotStyle values:<br />
<br />
<span style="white-space: pre-wrap;">  </span>Dashed<br />
<span style="white-space: pre-wrap;">  </span>DotDashed<br />
<span style="white-space: pre-wrap;">  </span>Dotted<br />
*)</span></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="line-thickness" id="line-thickness"></a><a href="computer-algebra2#line-thickness-note">line thickness</a></td>
<td>X = NormalDistribution[0, 1]<br />
data1 = RandomReal[X, 20]<br />
data2 = RandomReal[X, 20]<br />
<span style="color: gray">(* thickness is fraction of plot width: *)</span><br />
ListLinePlot[{data1, data2},<br />
<span style="white-space: pre-wrap;">  </span>PlotStyle -&gt; {Thickness[0.01], Thickness[0.02]}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="function-plot" id="function-plot"></a><img src="http://cdn.hyperpolyglot.org/images/function-plot.jpg" alt="function-plot.jpg" class="image" /><br />
<a href="computer-algebra2#function-plot-note">function plot</a></td>
<td>Plot[Sin[x], {x, -4, 4}]</td>
<td></td>
<td></td>
<td>wxplot2d(sin(x), [x, -4, 4]);</td>
</tr>
<tr>
<td><a name="parametric-plot" id="parametric-plot"></a><img src="http://cdn.hyperpolyglot.org/images/parametric-plot.jpg" alt="parametric-plot.jpg" class="image" /><br />
<a href="computer-algebra2#parametric-plot-note">parametric plot</a></td>
<td>ParametricPlot[{Sin[u], Sin[2 * u]},<br />
<span style="white-space: pre-wrap;">  </span>{u, 0, 2 * Pi}]</td>
<td></td>
<td></td>
<td>wxplot2d([parametric, sin(t), sin(2*t),<br />
<span style="white-space: pre-wrap;">  </span>[t, 0, 2*%pi]]);</td>
</tr>
<tr>
<td><a name="implicit-plot" id="implicit-plot"></a><img src="http://cdn.hyperpolyglot.org/images/implicit-plot.jpg" alt="implicit-plot.jpg" class="image" /><br />
<a href="computer-algebra2#implicit-plot-note">implicit plot</a></td>
<td>ContourPlot[x^2 + y^2 == 1, {x, -1, 1},<br />
<span style="white-space: pre-wrap;">  </span>{y, -1, 1}]</td>
<td></td>
<td></td>
<td>load(implicit_plot);<br />
<br />
wximplicit_plot(x^2 + y^2 = 1, [x, -1, 1],<br />
<span style="white-space: pre-wrap;">  </span>[y, -1, 1]);</td>
</tr>
<tr>
<td><a name="polar-plot" id="polar-plot"></a><img src="http://cdn.hyperpolyglot.org/images/polar-plot.jpg" alt="polar-plot.jpg" class="image" /><br />
<a href="computer-algebra2#polar-plot-note">polar plot</a></td>
<td>PolarPlot[Sin[3 * t], {t, 0, Pi}]</td>
<td></td>
<td></td>
<td>f(x) := sin(3 * x);<br />
wxplot2d([parametric, cos(t)*f(t), sin(t)*f(t),<br />
<span style="white-space: pre-wrap;">  </span>[t, 0, %pi]]);</td>
</tr>
<tr>
<td><a name="cubic-spline" id="cubic-spline"></a><img src="http://cdn.hyperpolyglot.org/images/cubic-spline.jpg" alt="cubic-spline.jpg" class="image" /><br />
<a href="computer-algebra2#cubic-spline-note">cubic spline</a></td>
<td>X = NormalDistribution[0, 1]<br />
data = Table[{i, RandomReal[X]},<br />
<span style="white-space: pre-wrap;">  </span>{i, 0, 20}]<br />
f = Interpolation[data,<br />
<span style="white-space: pre-wrap;">  </span>InterpolationOrder -&gt; 3]<br />
Show[ListPlot[data],<br />
<span style="white-space: pre-wrap;">  </span>Plot[f[x], {x, 0, 20}]]</td>
<td></td>
<td></td>
<td>load(interpol);<br />
load(distrib);<br />
load(draw);<br />
<br />
data: makelist([i, random_normal(0, 1)], i, 20);<br />
cspline(data);<br />
f(x):=<span style="white-space: pre-wrap;">''</span>%;<br />
wxdraw2d(explicit(f(x),x,0,20));</td>
</tr>
<tr>
<td><a name="area-chart" id="area-chart"></a><img src="http://cdn.hyperpolyglot.org/images/area-chart.jpg" width="75px" alt="area-chart.jpg" class="image" /><br />
<a href="computer-algebra2#area-chart-note">area chart</a></td>
<td>data = <span style="white-space: pre-wrap;">{{</span>7, 1, 3, 2, 8}, {1, 5, 3, 5, 1<span style="white-space: pre-wrap;">}}</span><br />
stacked = {data[[1]], data[[1]] + data[[2]]}<br />
ListLinePlot[stacked, Filling -&gt;<br />
<span style="white-space: pre-wrap;">  </span>{1 -&gt; {Axis, LightBlue},<br />
<span style="white-space: pre-wrap;">   </span>2 -&gt; <span style="white-space: pre-wrap;">{{</span>1}, LightRed}}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="surface-charts" id="surface-charts"></a><a href="computer-algebra2#surface-charts-note">surface charts</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="contour-plot" id="contour-plot"></a><img src="http://cdn.hyperpolyglot.org/images/contour-plot.jpg" alt="contour-plot.jpg" class="image" /><br />
<a href="computer-algebra2#contour-plot-note">contour plot</a></td>
<td><span style="color: gray">(* of function: *)</span><br />
ContourPlot[x * (y - 1), {x, 0, 10},<br />
<span style="white-space: pre-wrap;">  </span>{y, 0, 10}]<br />
<br />
<span style="color: gray">(* of data: *)</span><br />
X = NormalDistribution[0, 1]<br />
rand = Function[RandomReal[X]]<br />
data = Table[x * (y - 1) + 5 * rand[],<br />
<span style="white-space: pre-wrap;">  </span>{x, 0, 10}, {y, 0, 10}]<br />
ListContourPlot[data]</td>
<td></td>
<td></td>
<td>wxcontour_plot(x * (y-1), [x, 0, 10],<br />
<span style="white-space: pre-wrap;">  </span>[y, 0, 10]);</td>
</tr>
<tr>
<td><a name="heat-map" id="heat-map"></a><img src="http://cdn.hyperpolyglot.org/images/heat-map.jpg" alt="heat-map.jpg" class="image" /><br />
<a href="computer-algebra2#heat-map-note">heat map</a></td>
<td><span style="color: gray">(* of function: *)</span><br />
DensityPlot[Sin[x] * Sin[y],<br />
<span style="white-space: pre-wrap;">  </span>{x, -4, 4},<br />
<span style="white-space: pre-wrap;">  </span>{y, -4, 4}]<br />
<br />
<span style="color: gray">(* of data: *)</span><br />
X = NormalDistribution[0, 1]<br />
rand = Function[RandomReal[X]]<br />
data = Table[x * y + 10 * rand[],<br />
<span style="white-space: pre-wrap;">  </span>{x, 1, 10},<br />
<span style="white-space: pre-wrap;">  </span>{y, 1, 10}]<br />
ListDensityPlot[data]</td>
<td></td>
<td></td>
<td>wxplot3d (sin(x) * sin(y), [x,-4,4], [y,-4,4],<br />
<span style="white-space: pre-wrap;">  </span>[elevation, 0], [azimuth, 0],<br />
<span style="white-space: pre-wrap;">  </span>[grid, 100, 100], [mesh_lines_color, false]);</td>
</tr>
<tr>
<td><a name="shaded-surface-plot" id="shaded-surface-plot"></a><img src="http://cdn.hyperpolyglot.org/images/shaded-surface-plot.jpg" alt="shaded-surface-plot.jpg" class="image" /><br />
<a href="computer-algebra2#shaded-surface-plot-note">shaded surface plot</a></td>
<td>Plot3D[Exp[-(x^2 + y^2)], {x, -2, 2},<br />
<span style="white-space: pre-wrap;">  </span>{y, -2, 2}, MeshStyle -&gt; None]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="light-source" id="light-source"></a><a href="computer-algebra2#light-source-note">light source</a></td>
<td>lot3D[Exp[-(x^2 + y^2)],<br />
<span style="white-space: pre-wrap;">  </span>{x, -2, 2}, {y, -2, 2},<br />
<span style="white-space: pre-wrap;">  </span>MeshStyle -&gt; None,<br />
<span style="white-space: pre-wrap;">  </span>Lighting -&gt; <span style="white-space: pre-wrap;">{{"Point", White, {5, -5, 5}}}</span>]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="mesh-surface-plot" id="mesh-surface-plot"></a><img src="http://cdn.hyperpolyglot.org/images/mesh-surface-plot.jpg" alt="mesh-surface-plot.jpg" class="image" /><br />
<a href="computer-algebra2#mesh-surface-plot-note">mesh surface plot</a></td>
<td>Plot3D[Exp[-(x^2 + y^2)], {x, -2, 2},<br />
<span style="white-space: pre-wrap;">  </span>{y, -2, 2}, Lighting -&gt; {White},<br />
<span style="white-space: pre-wrap;">  </span>PlotStyle -&gt; White]</td>
<td></td>
<td></td>
<td>wxplot3d(exp(-(x^2 + y^2)),<br />
<span style="white-space: pre-wrap;">  </span>[x, -2, 2], [y, -2, 2],<br />
<span style="white-space: pre-wrap;">  </span>[palette, false], [color, black]);</td>
</tr>
<tr>
<td><a name="view-point" id="view-point"></a><a href="computer-algebra2#view-point-note">view point</a></td>
<td><span style="color: gray">(* (x, y, z) coordinates;<br />
<span style="white-space: pre-wrap;">   </span>(0, 0, 3) is from above: *)</span><br />
Plot3D[Exp[-(x^2 + y^2)],<br />
<span style="white-space: pre-wrap;">  </span>{x, -2, 2}, {y, -2, 2},<br />
<span style="white-space: pre-wrap;">  </span>MeshStyle -&gt; None,<br />
<span style="white-space: pre-wrap;">  </span>ViewPoint -&gt; {0, 0, 3}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="vector-field-plot" id="vector-field-plot"></a><img src="http://cdn.hyperpolyglot.org/images/vector-field-plot.jpg" alt="vector-field-plot.jpg" class="image" /><br />
<a href="computer-algebra2#vector-field-plot-note">vector field plot</a></td>
<td>StreamPlot[{x^2 + y, 1 + x - y^2}, {x, -4, 4}, {y, -4, 4}]</td>
<td></td>
<td></td>
<td>plotdf([x^2 + y, 1 + x - y^2], [x, -4, 4],<br />
<span style="white-space: pre-wrap;">  </span>[y, -4, 4]);</td>
</tr>
<tr>
<th colspan="5"><a name="chart-options" id="chart-options"></a><a href="computer-algebra2#chart-options-note">chart options</a></th>
</tr>
<tr>
<th></th>
<th>mathematica</th>
<th>sympy</th>
<th>sage</th>
<th>maxima</th>
</tr>
<tr>
<td><a name="chart-title" id="chart-title"></a><a href="computer-algebra2#chart-title-note">chart title</a></td>
<td><span style="color: gray">(* title on top by default *)</span><br />
Plot[Sin[x], {x, -4, 4},<br />
<span style="white-space: pre-wrap;">  </span>PlotLabel -&gt; "title example"]</td>
<td></td>
<td></td>
<td>wxplot2d(sin(x), [x, -4, 4],<br />
<span style="white-space: pre-wrap;">  </span>[title, "title example"]);<br />
<br />
data: 1, 1, 2, 2, 3, 3, 3, 3, 4];<br />
wxboxplot(data, title="title example");<br />
<br />
<span style="color: gray">/* title on top by default */</span></td>
</tr>
<tr>
<td><a name="axis-label" id="axis-label"></a><a href="computer-algebra2#axis-label-note">axis label</a></td>
<td>data = Table[{i, i^2}, {i, 1, 20}]<br />
ListLinePlot[data, AxesLabel -&gt; {x, x^2}]</td>
<td></td>
<td></td>
<td>x: makelist(i, i, 20);<br />
y: makelist(i^2, i, 20);<br />
wxplot2d([discrete, x, y],<br />
<span style="white-space: pre-wrap;">  </span>[xlabel, "x"], [ylabel, "x^2"]);</td>
</tr>
<tr>
<td><a name="legend" id="legend"></a><img src="http://cdn.hyperpolyglot.org/images/legend.jpg" alt="legend.jpg" class="image" /><br />
<a href="computer-algebra2#legend-note">legend</a></td>
<td>X = NormalDistribution[0, 1]<br />
data1 = RandomReal[X, 20]<br />
data2 = RandomReal[X, 20]<br />
ListLinePlot[{data1, data2},<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>PlotLegends -&gt; {"first", "second"}]</td>
<td></td>
<td></td>
<td><span style="color: gray">/* wxplot2d includes a legend by default.<br />
<br />
Provide [legend, false] as argument to suppress it. */</span></td>
</tr>
<tr>
<td><a name="data-label" id="data-label"></a><a href="computer-algebra2#data-label-note">data label</a></td>
<td>data = <span style="white-space: pre-wrap;">{{</span>313, 3.7}, {62, .094}, {138, 6.6},<br />
<span style="white-space: pre-wrap;">  </span>{113, 0.76}, {126, 0.15}}<br />
<br />
<span style="color: gray">(* The {0, -1} argument of Text[] centers the label above the data point. *)</span><br />
Show[ListPlot[data,<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>AxesLabel -&gt; {"pop", "area"}],<br />
<span style="white-space: pre-wrap;">  </span>Graphics[Text["USA", data[[1]], {0, -1}]],<br />
<span style="white-space: pre-wrap;">  </span>Graphics[Text["UK", data[[2]], {0, -1}]],<br />
<span style="white-space: pre-wrap;">  </span>Graphics[Text["Russia", data[[3]], {0, -1}]],<br />
<span style="white-space: pre-wrap;">  </span>Graphics[Text["Mexico", data[[4]], {0, -1}]],<br />
<span style="white-space: pre-wrap;">  </span>Graphics[Text["Japan", data[[5]], {0, -1}]]]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="named-colors" id="named-colors"></a><a href="computer-algebra2#named-colors-note">named colors</a></td>
<td>White Gray Black Transparent<br />
<br />
Blue Brown Cyan Green Magenta Orange Pink Purple Red Yellow<br />
<br />
LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightPink LightPurple LightRed LightYellow</td>
<td></td>
<td></td>
<td>white gray black<br />
<br />
gray0 gray10 gray100 gray20 gray30 gray40 gray50 gray60 gray70 gray80 gray90 gray100 grey grey0 grey10 grey20 grey30 grey40 grey50 grey60 grey70 grey80 grey90 grey100<br />
<br />
aquamarine beige blue brown coral cyan forest_green gold goldenrod green khaki magenta medium_blue midnight_blue navy orange orange_red pink plum purple red royalblue salmon sea_green skyblue spring_green turquoise violet yellow<br />
<br />
dark_blue dark_cyan dark_goldenrod dark_gray dark_green dark_grey dark_khaki dark_magenta dark_orange dark_pink dark_red dark_salmon dark_turquoise dark_violet dark_yellow<br />
<br />
light_blue light_coral light_cyan light_goldenrod light_gray light_green light_grey light_magenta light_pink light_red light_salmon light_turquoise light_yellow</td>
</tr>
<tr>
<td><a name="rgb-color" id="rgb-color"></a><a href="computer-algebra2#rgb-color-note">rgb color</a></td>
<td>RGBColor[1, 0, 0]<br />
<span style="color: gray">(* with opacity: *)</span><br />
RGBColor[1, 0, 0, 0.5]</td>
<td></td>
<td></td>
<td>[color, "#FF0000"]</td>
</tr>
<tr>
<td><a name="background-color" id="background-color"></a><a href="computer-algebra2#background-color-note">background color</a></td>
<td>Plot[Sin[x], {x, 0, 2 Pi},<br />
<span style="white-space: pre-wrap;">  </span>Background -&gt; Black,<br />
<span style="white-space: pre-wrap;">  </span>PlotStyle -&gt; White,<br />
<span style="white-space: pre-wrap;">  </span>AxesStyle -&gt; White,<br />
<span style="white-space: pre-wrap;">  </span>TicksStyle -&gt; White,<br />
<span style="white-space: pre-wrap;">  </span>GridLines -&gt; Automatic,<br />
<span style="white-space: pre-wrap;">  </span>GridLinesStyle -&gt; White]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="axis-limits" id="axis-limits"></a><a href="computer-algebra2#axis-limits-note">axis limits</a></td>
<td>Plot[x^2, {x, 0, 20},<br />
<span style="white-space: pre-wrap;">  </span>PlotRange -&gt; <span style="white-space: pre-wrap;">{{0, 20}, {-200, 500}}</span>]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="logarithmic-y-axis" id="logarithmic-y-axis"></a><a href="computer-algebra2#logarithmic-y-axis-note">logarithmic y-axis</a></td>
<td>LogPlot[{x^2, x^3, x^4, x^5},<br />
<span style="white-space: pre-wrap;">  </span>{x, 0, 20}]</td>
<td></td>
<td></td>
<td>x: makelist(i, i, 20);<br />
wxplot2d([<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>[discrete, x, makelist(i^2, i, 20)],<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>[discrete, x, makelist(i^3, i, 20)]],<br />
<span style="white-space: pre-wrap;">  </span>[logy, true]);</td>
</tr>
<tr>
<td><a name="aspect-ratio" id="aspect-ratio"></a><a href="computer-algebra2#aspect-ratio-note">aspect ratio</a></td>
<td><span style="color: gray">(* aspect ratio is height divided by width: *)</span><br />
Plot[Sin[x], {x, 0, 2 Pi}, AspectRatio -&gt; 0.25]<br />
<br />
<span style="color: gray">(* In the notebook, dragging the corner of an image increases or decreases the size, but aspect ratio is preserved. *)</span></td>
<td></td>
<td></td>
<td>wxplot2d(sin(x), [x, -4, 4],<br />
<span style="white-space: pre-wrap;">  </span>[yx_ratio, 0.25]);<br />
<br />
<span style="color: gray">/* Image size can’t be changed in notebook. */</span></td>
</tr>
<tr>
<td><a name="ticks" id="ticks"></a><a href="computer-algebra2#ticks-note">ticks</a></td>
<td>Plot[Sin[x], {x, 0, 2 Pi}, Ticks -&gt; None]<br />
<br />
Plot[Sin[x], {x, 0, 2 Pi},<br />
<span style="white-space: pre-wrap;">  </span>Ticks -&gt; <span style="white-space: pre-wrap;">{{0, Pi, 2*Pi}, {-1, 0, 1}}</span>]</td>
<td></td>
<td></td>
<td>wxplot2d(sin(x), [x, -4, 4],<br />
<span style="white-space: pre-wrap;">  </span>[xtics, -4, 2, 4],<br />
<span style="white-space: pre-wrap;">  </span>[ytics, -1, 0.5, 1]);</td>
</tr>
<tr>
<td><a name="grid-lines" id="grid-lines"></a><a href="computer-algebra2#grid-lines-note">grid lines</a></td>
<td>Plot[Sin[x], {x, 0, 2 Pi},<br />
<span style="white-space: pre-wrap;">  </span>GridLines -&gt; Automatic]<br />
<br />
Plot[Sin[x], {x, 0, 2 Pi},<br />
<span style="white-space: pre-wrap;">  </span>GridLines -&gt; <span style="white-space: pre-wrap;">{{</span>0, 1, 2, 3, 4, 5, 6},<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>{-1, -0.5, 0, 0.5, 1}}]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="grid-of-subplots" id="grid-of-subplots"></a><img src="http://cdn.hyperpolyglot.org/images/subplot-grid.jpg" alt="subplot-grid.jpg" class="image" /><br />
<a href="computer-algebra2#grid-of-subplots-note">grid of subplots</a></td>
<td>GraphicsGrid[Table[Table[<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>Histogram[RandomReal[X, 100], 10],<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>{i, 1, 2}],<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>{j, 1, 2}]]</td>
<td></td>
<td></td>
<td>load(distrib);<br />
<br />
x: makelist(makelist(random_normal(0, 1), i, 50),<br />
<span style="white-space: pre-wrap;">  </span>j, 4);<br />
p: makelist(histogram_description(x[i]), i, 4);<br />
wxdraw(gr2d(p[1]), gr2d(p[2]), gr2d(p[3]),<br />
<span style="white-space: pre-wrap;">  </span>gr2d(p[4]), columns=2);</td>
</tr>
<tr>
<td><a name="save-plot-as-png" id="save-plot-as-png"></a><a href="computer-algebra2#save-plot-as-png-note">save plot as png</a></td>
<td>Export["hist.png",<br />
<span style="white-space: pre-wrap;">  </span>Histogram[RandomReal[X, 100], 10]]</td>
<td></td>
<td></td>
<td><span style="color: gray"><em>After creating a plot, run</em> gnuplot <em>on the</em> .gnuplot <em>file generated in the home directory:</em></span><br />
<br />
$ gnuplot maxout.gnuplot</td>
</tr>
<tr>
<th></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">____________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">____________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">____________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">____________________________________________________</span></span></th>
</tr>
</table>
<p><a name="symbolic-expr-note" id="symbolic-expr-note"></a></p>
<h1 id="toc0"><span><a href="computer-algebra2#symbolic-expr">Symbolic Expressions</a></span></h1>
<p>In many programming languages, attempting to evaluate an expression with an undefined variable results in an error. Some languages assign a default value to variables so that such expressions can be evaluated.</p>
<p>In a CAS, undefined variables are treated as unknowns; expressions which contains them are <em>symbolic expressions</em>. When evaluating them, if the unknowns cannot be eliminated, the expression cannot be reduced to a numeric value. The expression then evaluates to a possibly simplified or normalized version of itself. Symbolic expressions are first class values; they can be stored in variables or passed to functions.</p>
<p>An application of symbolic expressions is a function which solves a system of equations. Without symbolic expressions, it would be awkward for the caller to specify the equations to be solved.</p>
<p><a name="symbolic-expr-literal-note" id="symbolic-expr-literal-note"></a></p>
<h2 id="toc1"><span><a href="computer-algebra2#symbolic-expr-literal">literal</a></span></h2>
<p>How to create a symbolic expression.</p>
<p>In most CAS systems, any expression an undefined variables is automatically a a symbolic expression.</p>
<p><strong>sympy:</strong></p>
<p>In SymPy, unknowns must be declared. This is a consequence of SymPy being implemented as a library in a language which throws exceptions when undefined variables are encountered.</p>
<p><a name="prevent-simplification-note" id="prevent-simplification-note"></a></p>
<h2 id="toc2"><span><a href="computer-algebra2#prevent-simplification">prevent simplification</a></span></h2>
<p><a name="symbolic-expr-var-update-note" id="symbolic-expr-var-update-note"></a></p>
<h2 id="toc3"><span><a href="computer-algebra2#symbolic-expr-var-update">variable update</a></span></h2>
<p>Do symbolic expressions "see" changes to the unknown variables they contain.</p>
<p><a name="symbolic-expr-subst-note" id="symbolic-expr-subst-note"></a></p>
<h2 id="toc4"><span><a href="computer-algebra2#symbolic-expr-subst">substitute</a></span></h2>
<p><a name="piecewise-symbolic-expr-note" id="piecewise-symbolic-expr-note"></a></p>
<h2 id="toc5"><span><a href="computer-algebra2#piecewise-symbolic-expr">piecewise-defined expression</a></span></h2>
<p><a name="simplify-note" id="simplify-note"></a></p>
<h2 id="toc6"><span><a href="computer-algebra2#simplify">simplify</a></span></h2>
<p><a name="assumption-note" id="assumption-note"></a></p>
<h2 id="toc7"><span><a href="computer-algebra2#assumption">assumption</a></span></h2>
<p><a name="assumption-predicates-note" id="assumption-predicates-note"></a></p>
<h2 id="toc8"><span><a href="computer-algebra2#assumption-predicates">assumption predicates</a></span></h2>
<p><a name="list-assumptions-note" id="list-assumptions-note"></a></p>
<h2 id="toc9"><span><a href="computer-algebra2#list-assumptions">list assumptions</a></span></h2>
<p><a name="rm-assumption-note" id="rm-assumption-note"></a></p>
<h2 id="toc10"><span><a href="computer-algebra2#rm-assumption">remove assumption</a></span></h2>
<p><a name="calculus-note" id="calculus-note"></a></p>
<h1 id="toc11"><span><a href="computer-algebra2#calculus">Calculus</a></span></h1>
<p><a name="limit-note" id="limit-note"></a></p>
<h2 id="toc12"><span><a href="computer-algebra2#limit">limit</a></span></h2>
<p><a name="limit-at-infinity-note" id="limit-at-infinity-note"></a></p>
<h2 id="toc13"><span><a href="computer-algebra2#limit-at-infinity">limit at infinity</a></span></h2>
<p><a name="one-sided-limit-note" id="one-sided-limit-note"></a></p>
<h2 id="toc14"><span><a href="computer-algebra2#one-sided-limit">one-sided limit</a></span></h2>
<p><a name="derivative-note" id="derivative-note"></a></p>
<h2 id="toc15"><span><a href="computer-algebra2#derivative">derivative</a></span></h2>
<p><a name="derivative-func-note" id="derivative-func-note"></a></p>
<h2 id="toc16"><span><a href="computer-algebra2#derivative-func">derivative of a function</a></span></h2>
<p><a name="derivative-const-note" id="derivative-const-note"></a></p>
<h2 id="toc17"><span><a href="computer-algebra2#derivative-const">constants</a></span></h2>
<p><a name="higher-order-derivative-note" id="higher-order-derivative-note"></a></p>
<h2 id="toc18"><span><a href="computer-algebra2#higher-order-derivative">higher order derivative</a></span></h2>
<p><a name="mixed-partial-derivative-note" id="mixed-partial-derivative-note"></a></p>
<h2 id="toc19"><span><a href="computer-algebra2#mixed-partial-derivative">mixed partial derivative</a></span></h2>
<p><a name="div-grad-curl-note" id="div-grad-curl-note"></a></p>
<h2 id="toc20"><span><a href="computer-algebra2#div-grad-curl">div, grad, and curl</a></span></h2>
<p><a name="antiderivative-note" id="antiderivative-note"></a></p>
<h2 id="toc21"><span><a href="computer-algebra2#antiderivative">antiderivative</a></span></h2>
<p><a name="definite-integral-note" id="definite-integral-note"></a></p>
<h2 id="toc22"><span><a href="computer-algebra2#definite-integral">definite integral</a></span></h2>
<p><a name="improper-integral-note" id="improper-integral-note"></a></p>
<h2 id="toc23"><span><a href="computer-algebra2#improper-integral">improper integral</a></span></h2>
<p><a name="double-integral-note" id="double-integral-note"></a></p>
<h2 id="toc24"><span><a href="computer-algebra2#double-integral">double integral</a></span></h2>
<p><a name="find-poles-note" id="find-poles-note"></a></p>
<h2 id="toc25"><span><a href="computer-algebra2#find-poles">find poles</a></span></h2>
<p><a name="residue-note" id="residue-note"></a></p>
<h2 id="toc26"><span><a href="computer-algebra2#residue">residue</a></span></h2>
<p><a name="sum-note" id="sum-note"></a></p>
<h2 id="toc27"><span><a href="computer-algebra2#sum">sum</a></span></h2>
<p><a name="series-sum-note" id="series-sum-note"></a></p>
<h2 id="toc28"><span><a href="computer-algebra2#series-sum">series sum</a></span></h2>
<p><a name="series-expansion-func-note" id="series-expansion-func-note"></a></p>
<h2 id="toc29"><span><a href="computer-algebra2#series-expansion-func">series expansion of function</a></span></h2>
<p><a name="omitted-order-term-note" id="omitted-order-term-note"></a></p>
<h2 id="toc30"><span><a href="computer-algebra2#omitted-order-term">omitted order term</a></span></h2>
<p><a name="product-note" id="product-note"></a></p>
<h2 id="toc31"><span><a href="computer-algebra2#product">product</a></span></h2>
<p><a name="equations-unknowns-note" id="equations-unknowns-note"></a></p>
<h1 id="toc32"><span><a href="computer-algebra2#eqn">Equations and Unknowns</a></span></h1>
<p><a name="solve-eqn-note" id="solve-eqn-note"></a></p>
<h2 id="toc33"><span><a href="computer-algebra2#solve-eqn">solve equation</a></span></h2>
<p><a name="solve-eqns-note" id="solve-eqns-note"></a></p>
<h2 id="toc34"><span><a href="computer-algebra2#solve-eqns">solve equations</a></span></h2>
<p><a name="differential-eqn-note" id="differential-eqn-note"></a></p>
<h2 id="toc35"><span><a href="computer-algebra2#differential-eqn">differential equation</a></span></h2>
<p><a name="differential-eqn-boundary-condition-note" id="differential-eqn-boundary-condition-note"></a></p>
<h2 id="toc36"><span><a href="computer-algebra2#differential-eqn-boundary-condition">differential equation with boundary condition</a></span></h2>
<p><a name="differential-eqns-note" id="differential-eqns-note"></a></p>
<h2 id="toc37"><span><a href="computer-algebra2#differential-eqns">differential equations</a></span></h2>
<p><a name="recurrence-eqn-note" id="recurrence-eqn-note"></a></p>
<h2 id="toc38"><span><a href="computer-algebra2#recurrence-eqn">recurrence equation</a></span></h2>
<p><a name="optimization-note" id="optimization-note"></a></p>
<h1 id="toc39"><span><a href="computer-algebra2#optimization">Optimization</a></span></h1>
<p>An optimization problem consists of a real-valued function called the <em>objective function</em>.</p>
<p>The objective function takes one or more <em>input variables</em>. In the case of a maximization problem, the goal is to find the value for the input variables where the objective function achieves its maximum value. Similarly for a minimization function one looks for the values for which the objective function achieves its minimum value.</p>
<p><a name="minimize-note" id="minimize-note"></a></p>
<h2 id="toc40"><span><a href="computer-algebra2#minimize">minimize</a></span></h2>
<p>How to solve a minimization problem in one variable.</p>
<p><a name="maximize-note" id="maximize-note"></a></p>
<h2 id="toc41"><span><a href="computer-algebra2#maximize">maximize</a></span></h2>
<p>How to solve a maximization problem.</p>
<p>We can use a function which solves minimization problems to solve maximization problems by negating the objective function. The downside is we might forget the minimum value returned is the negation of the maximum value we seek.</p>
<p><a name="optimize-unknown-param-note" id="optimize-unknown-param-note"></a></p>
<h2 id="toc42"><span><a href="computer-algebra2#optimize-unknown-param">objective with unknown parameter</a></span></h2>
<p>How to solve an optimization when the objective function contains unknown parameters.</p>
<p><a name="unbounded-behavior-note" id="unbounded-behavior-note"></a></p>
<h2 id="toc43"><span><a href="computer-algebra2#unbounded-behavior">unbounded behavior</a></span></h2>
<p>What happens when attempting to solve an unbounded optimization problem.</p>
<p><a name="optimize-multiple-var-note" id="optimize-multiple-var-note"></a></p>
<h2 id="toc44"><span><a href="computer-algebra2#optimize-multiple-var">multiple variables</a></span></h2>
<p>How to solve an optimization problem with more than one input variable.</p>
<p><a name="optimize-constraints-note" id="optimize-constraints-note"></a></p>
<h2 id="toc45"><span><a href="computer-algebra2#optimize-constraints">constraints</a></span></h2>
<p>How to solve an optimization with constraints on the input variable. The constrains are represented by inequalities.</p>
<p><a name="infeasible-behavior-note" id="infeasible-behavior-note"></a></p>
<h2 id="toc46"><span><a href="computer-algebra2#infeasible-behavior">infeasible behavior</a></span></h2>
<p>What happens when attempting to solve an optimization problem when the solution set for the constraints is empty.</p>
<p><a name="optimize-int-var-note" id="optimize-int-var-note"></a></p>
<h2 id="toc47"><span><a href="computer-algebra2#optimize-int-var">integer variables</a></span></h2>
<p>How to solve an optimization problem when the input variables are constrained to linear values.</p>
<p><a name="vectors-note" id="vectors-note"></a></p>
<h1 id="toc48"><span><a href="computer-algebra2#vectors">Vectors</a></span></h1>
<p><a name="vec-literal-note" id="vec-literal-note"></a></p>
<h2 id="toc49"><span><a href="computer-algebra2#vec-literal">vector literal</a></span></h2>
<p>The notation for a vector literal.</p>
<p><a name="const-vec-note" id="const-vec-note"></a></p>
<h2 id="toc50"><span><a href="computer-algebra2#const-vec">constant vector</a></span></h2>
<p>How to create a vector with components all the same.</p>
<p><a name="vec-coordinate-note" id="vec-coordinate-note"></a></p>
<h2 id="toc51"><span><a href="computer-algebra2#vec-coordinate">vector coordinate</a></span></h2>
<p>How to get one of the coordinates of a vector.</p>
<p><a name="vec-dim-note" id="vec-dim-note"></a></p>
<h2 id="toc52"><span><a href="computer-algebra2#vec-dim">vector dimension</a></span></h2>
<p>How to get the number of coordinates of a vector.</p>
<p><a name="vec-element-wise-note" id="vec-element-wise-note"></a></p>
<h2 id="toc53"><span><a href="computer-algebra2#vec-element-wise">element-wise arithmetic operators</a></span></h2>
<p>How to perform an element-wise arithmetic operation on vectors.</p>
<p><a name="vec-length-mismatch-note" id="vec-length-mismatch-note"></a></p>
<h2 id="toc54"><span><a href="computer-algebra2#vec-length-mismatch">vector length mismatch</a></span></h2>
<p>What happens when an element-wise arithmetic operation is performed on vectors of different dimension.</p>
<p><a name="vec-scalar-note" id="vec-scalar-note"></a></p>
<h2 id="toc55"><span><a href="computer-algebra2#vec-scalar">scalar multiplication</a></span></h2>
<p>How to multiply a scalar with a vector.</p>
<p><a name="vec-dot-note" id="vec-dot-note"></a></p>
<h2 id="toc56"><span><a href="computer-algebra2#vec-dot">dot product</a></span></h2>
<p>How to compute the dot product of two vectors.</p>
<p><a name="vec-cross-note" id="vec-cross-note"></a></p>
<h2 id="toc57"><span><a href="computer-algebra2#vec-cross">cross product</a></span></h2>
<p>How to compute the cross product of two three-dimensional vectors.</p>
<p><a name="vec-norms-note" id="vec-norms-note"></a></p>
<h2 id="toc58"><span><a href="computer-algebra2#vec-norms">norms</a></span></h2>
<p>How to compute the norm of a vector.</p>
<p><a name="matrices-note" id="matrices-note"></a></p>
<h1 id="toc59"><span><a href="computer-algebra2#matrices">Matrices</a></span></h1>
<p><a name="matrix-literal-ctor-note" id="matrix-literal-ctor-note"></a></p>
<h2 id="toc60"><span><a href="computer-algebra2#matrix-literal-ctor">literal or constructor</a></span></h2>
<p>Literal syntax or constructor for creating a matrix.</p>
<p><strong>mathematica:</strong></p>
<p>Matrices are represented as lists of lists. No error is generated if one of the rows contains too many or two few elements. The <em>MatrixQ</em> predicate can be used to test whether a list of lists is matrix: i.e. all of the sublists contain numbers and are of the same length.</p>
<p>Matrices are displayed by Mathematica using list notation. To see a matrix as it would be displayed in mathematical notation, use the <em>MatrixForm</em> function.</p>
<p><a name="matrix-from-seq-note" id="matrix-from-seq-note"></a></p>
<h2 id="toc61"><span><a href="computer-algebra2#matrix-from-seq">construct from sequence</a></span></h2>
<p><a name="const-matrices-note" id="const-matrices-note"></a></p>
<h2 id="toc62"><span><a href="computer-algebra2#const-matrices">constant matrices</a></span></h2>
<p><a name="diagonal-matrices-note" id="diagonal-matrices-note"></a></p>
<h2 id="toc63"><span><a href="computer-algebra2#diagonal-matrices">diagonal matrices</a></span></h2>
<p><a name="matrix-formula-note" id="matrix-formula-note"></a></p>
<h2 id="toc64"><span><a href="computer-algebra2#matrix-formula">matrix by formula</a></span></h2>
<p><a name="matrix-dim-note" id="matrix-dim-note"></a></p>
<h2 id="toc65"><span><a href="computer-algebra2#matrix-dim">dimensions</a></span></h2>
<p>How to get the number of rows and columns of a matrix.</p>
<p><a name="matrix-elem-lookup-note" id="matrix-elem-lookup-note"></a></p>
<h2 id="toc66"><span><a href="computer-algebra2#matrix-elem-lookup">element lookup</a></span></h2>
<p>How to access an element of a matrix.</p>
<p>The anguages described here follow the mathematical convention of putting the row index before the column index.</p>
<p><a name="extract-matrix-row-note" id="extract-matrix-row-note"></a></p>
<h2 id="toc67"><span><a href="computer-algebra2#extract-matrix-row">extract row</a></span></h2>
<p>How to access a row.</p>
<p><a name="extract-matrix-col-note" id="extract-matrix-col-note"></a></p>
<h2 id="toc68"><span><a href="computer-algebra2#extract-matrix-col">extract column</a></span></h2>
<p>How to access a column.</p>
<p><a name="extract-submatrix-note" id="extract-submatrix-note"></a></p>
<h2 id="toc69"><span><a href="computer-algebra2#extract-submatrix">extract submatrix</a></span></h2>
<p>How to access a submatrix.</p>
<p><a name="matrix-scalar-mult-note" id="matrix-scalar-mult-note"></a></p>
<h2 id="toc70"><span><a href="computer-algebra2#matrix-scalar-mult">scalar multiplication</a></span></h2>
<p>How to multiply a matrix by a scalar.</p>
<p><a name="matrix-elem-wise-op-note" id="matrix-elem-wise-op-note"></a></p>
<h2 id="toc71"><span><a href="computer-algebra2#matrix-elem-wise-op">element-wise operators</a></span></h2>
<p>Operators which act on two identically sized matrices element by element. Note that element-wise multiplication of two matrices is used less frequently in mathematics than matrix multiplication.</p>
<p><a name="matrix-mult-note" id="matrix-mult-note"></a></p>
<h2 id="toc72"><span><a href="computer-algebra2#matrix-mult">product</a></span></h2>
<p>How to multiply matrices.</p>
<p>Matrix multiplication in non-commutative and only requires that the number of columns of the matrix on the left match the number of rows of the matrix. Element-wise multiplication, by contrast, is commutative and requires that the dimensions of the two matrices be equal.</p>
<p><a name="matrix-power-note" id="matrix-power-note"></a></p>
<h2 id="toc73"><span><a href="computer-algebra2#matrix-power">power</a></span></h2>
<p>How to compute the power of a square matrix.</p>
<p>For non-negative integers, the power of a matrix is defined recursively with <em>A<sup>0</sup> = I</em> and <em>A<sup>n</sup> = A<sup>n-1</sup> ⋅ A</em>.</p>
<p>If the matrix is invertible, the power is defined for negative integers by <em>A<sup>n</sup> = (A<sup>-1</sup>)<sup>-n</sup></em>.</p>
<p><a name="matrix-exponential-note" id="matrix-exponential-note"></a></p>
<h2 id="toc74"><span><a href="computer-algebra2#matrix-exponential">exponential</a></span></h2>
<span class="equation-number">(1)</span>
<div class="math-equation" id="equation-1">\begin{align} \exp(A) = \sum_{i=0}^\infty A^i \end{align}</div>
<p><a name="matrix-log-note" id="matrix-log-note"></a></p>
<h2 id="toc75"><span><a href="computer-algebra2#matrix-log">log</a></span></h2>
<p><a name="kronecker-prod-note" id="kronecker-prod-note"></a></p>
<h2 id="toc76"><span><a href="computer-algebra2#kronecker-prod">kronecker product</a></span></h2>
<p>The <a href="http://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a> is a non-commutative operation defined on any two matrices. If A is m x n and B is p x q, then the Kronecker product is a matrix with dimensions mp x nq.</p>
<p><a name="matrix-norms-note" id="matrix-norms-note"></a></p>
<h2 id="toc77"><span><a href="computer-algebra2#matrix-norms">norms</a></span></h2>
<p>How to compute the 1-norm, the 2-norm, the infinity norm, and the frobenius norm.</p>
<p><a name="matrix-transpose-note" id="matrix-transpose-note"></a></p>
<h2 id="toc78"><span><a href="computer-algebra2#matrix-transpose">transpose</a></span></h2>
<p><a name="matrix-conjugate-transpose-note" id="matrix-conjugate-transpose-note"></a></p>
<h2 id="toc79"><span><a href="computer-algebra2#matrix-conjugate-transpose">conjugate transpose</a></span></h2>
<p><a name="matrix-inverse-note" id="matrix-inverse-note"></a></p>
<h2 id="toc80"><span><a href="computer-algebra2#matrix-inverse">inverse</a></span></h2>
<p><a name="row-echelon-form-note" id="row-echelon-form-note"></a></p>
<h2 id="toc81"><span><a href="computer-algebra2#row-echelon-form">row echelon form</a></span></h2>
<p><a name="pseudoinverse-note" id="pseudoinverse-note"></a></p>
<h2 id="toc82"><span><a href="computer-algebra2#pseudoinverse">pseudoinverse</a></span></h2>
<p><a name="determinant-note" id="determinant-note"></a></p>
<h2 id="toc83"><span><a href="computer-algebra2#determinant">determinant</a></span></h2>
<p>The determinant of a square matrix is equal to the product of the eigenvalues of a matrix. It is zero if and only if the matrix is nonsingular.</p>
<p>The determinant can be computed by calculating the matrix cofactors along a row or column, multiplying each by the row or column entry, and then summing. This technique, called Laplace's formula, requires <em>n!</em> multiplications, where <em>n</em> is number of rows in matrix, and thus is impractical for large matrices.</p>
<p><a name="trace-note" id="trace-note"></a></p>
<h2 id="toc84"><span><a href="computer-algebra2#trace">trace</a></span></h2>
<p>The trace of a matrix is the sum of the diagonal entries. It is equal to the sum of the eigenvalues of the matrix.</p>
<p><a name="characteristic-polynomial-note" id="characteristic-polynomial-note"></a></p>
<h2 id="toc85"><span><a href="computer-algebra2#characteristic-polynomial">characteristic polynomial</a></span></h2>
<p>The charateristic polynomial of a matrix <em>A</em> can be defined by:</p>
<span class="equation-number">(2)</span>
<div class="math-equation" id="equation-2">\begin{align} p(t) = \mathrm{det}(t ⋅ I - A) \end{align}</div>
<p>The eigenvalues of <em>A</em> are the roots of <em>p(t)</em>.</p>
<p><a name="minimal-polynomial-note" id="minimal-polynomial-note"></a></p>
<h2 id="toc86"><span><a href="computer-algebra2#minimal-polynomial">minimal polynomial</a></span></h2>
<p><a name="matrix-rank-note" id="matrix-rank-note"></a></p>
<h2 id="toc87"><span><a href="computer-algebra2#matrix-rank">rank</a></span></h2>
<p><a name="nullspace-basis-note" id="nullspace-basis-note"></a></p>
<h2 id="toc88"><span><a href="computer-algebra2#nullspace-basis">nullspace basis</a></span></h2>
<p><a name="eigenval-note" id="eigenval-note"></a></p>
<h2 id="toc89"><span><a href="computer-algebra2#eigenval">eigenvalues</a></span></h2>
<p><a name="eigenvec-note" id="eigenvec-note"></a></p>
<h2 id="toc90"><span><a href="computer-algebra2#eigenvec">eigenvectors</a></span></h2>
<p><a name="lu-decomposition-note" id="lu-decomposition-note"></a></p>
<h2 id="toc91"><span><a href="computer-algebra2#lu-decomposition">LU decomposition</a></span></h2>
<p>A factorization into a lower triangular matrix <em>L</em>, an upper triangular matrix <em>U</em>, and a permutation matrix <em>P</em>. Typically the identity is <em>PA = LU</em>.</p>
<p>An LU factorization of a square matrix always exists. It can be found using a modified variant of Gaussian elimination. For an <em>n × n</em> matrix it requires about <em>n<sup>3</sup></em> scalar multiplications.</p>
<p>LU factorization is an efficient way (1) to solve a system of equations, (2) to find the inverse of a matrix, and (3) to compute the determinant of a matrix.</p>
<p>To use <em>PA = LU</em> to solve <em>Ax = b</em>, first solve for <em>y</em> in <em>Ly = Pb</em> using forward substitution, then solve for <em>x</em> in <em>Ux = y</em> using backward substitution.</p>
<p>To use <em>PA = LU</em> to find the inverse <em>B</em> of <em>A</em>, first solve for <em>Y</em> in <em>LU = P</em> using forward substitution, then solve for <em>UB = Y</em> using backward substitution.</p>
<p>The determinant of <em>A</em> can be computed from the diagonal entries of <em>L</em> and <em>U</em>. To get the sign correctly, one must count the number of row exchanges <em>S</em> in the permutation matrix <em>P</em>:</p>
<span class="equation-number">(3)</span>
<div class="math-equation" id="equation-3">\begin{align} (-1)^S \prod_{i=1}^n l_{ii} \prod_{i=1}^n u_{ii} \end{align}</div>
<p><a name="qr-decomposition-note" id="qr-decomposition-note"></a></p>
<h2 id="toc92"><span><a href="computer-algebra2#qr-decomposition">QR decomposition</a></span></h2>
<p>A factorization of a square matrix into an orthogonal matrix <em>Q</em> and an upper triangular matrix <em>R</em>.</p>
<p>The QR factorization is unique when the original matrix <em>A</em> is invertible.</p>
<p>The Gram-Schmidt process can be used to compute a QR factorization, though it is not the most numerically stable method.</p>
<p>If <em>a<sub>1</sub>, …, a<sub>n</sub></em> are the column vectors of the original matrix <em>A</em>, then the Gram-Schmidt process yields the column vectors <em>e<sub>1</sub>, …, e<sub>n</sub></em> of the orthogonal matrix <em>Q</em>.</p>
<p>The QR algorithm uses QR factorizations to iteratively find eigenvalues. For each iteration we perform a QR factorization on A<sub>k</sub>:</p>
<span class="equation-number">(4)</span>
<div class="math-equation" id="equation-4">\begin{equation} Q_k R_k = A_k \end{equation}</div>
<p>Then we multiply Q_k and R_k in reverse to get A<sub>k+1</sub>:</p>
<span class="equation-number">(5)</span>
<div class="math-equation" id="equation-5">\begin{equation} A_{k+1} = R_k Q_k \end{equation}</div>
<p>Usually the sequence of A<sub>k</sub> will converge to a triangular matrix with the eigenvalues on the diagonal. The limit matrix is similar to the original matrix because</p>
<span class="equation-number">(6)</span>
<div class="math-equation" id="equation-6">\begin{equation} A_{k+1} = R_k Q_k = R_k A_k R_k^{-1} \end{equation}</div>
<p>and hence has the same eigenvalues.</p>
<p><a name="spectral-decomposition-note" id="spectral-decomposition-note"></a></p>
<h2 id="toc93"><span><a href="computer-algebra2#spectral-decomposition">spectral decomposition</a></span></h2>
<p>The spectral decomposition of a square matrix <em>A</em> is a factorization <em>P ⋅D ⋅ P<sup>-1</sup></em> where <em>P</em> is invertible and <em>D</em> is diagonal.</p>
<p>The spectral decomposition is also called the <em>eigendecomposition</em>. The values on the diagonal of <em>D</em> are eigenvalues of the matrix <em>A</em> and the rows of <em>P</em> are eigenvectors.</p>
<p>If a spectral decomposition exists, the matrix <em>A</em> is said to be <em>diagonalizable</em>.</p>
<p>If an invertible matrix <em>P</em> exists such that <em>A = P ⋅ B ⋅ P<sup>-1</sup></em>, then <em>A</em> and <em>B</em> are said to be <em>similar</em>.</p>
<p>According to the spectral theorem, a spectral decomposition exists when the matrix <em>A</em> is <em>normal</em>, which means it commutes with its conjugate transpose.</p>
<p>If a matrix <em>A</em> is symmetric, then a spectral decomposition <em>P ⋅ D ⋅ P<sup>-1</sup></em> exists, and moreover <em>P</em> and <em>D</em> are real matrices.</p>
<p><a name="svd-note" id="svd-note"></a></p>
<h2 id="toc94"><span><a href="computer-algebra2#svd">singular value decomposition</a></span></h2>
<p>A singluar value decomposition of a matrix <em>A</em> is a factorization into a diagonal matrix <em>S</em> and unitary matrices <em>U</em> and <em>V</em> such that <em>A = U ⋅ S ⋅ V<sup>*</sup></em>.</p>
<p>Unlike the spectral decomposition, an SVD always exists, even if <em>A</em> is not square. The values on the diagonal of <em>S</em> are called the singular values, and they are the eigenvalues of <em>A ⋅ A<sup>*</sup></em>.</p>
<p><a name="jordan-decomposition-note" id="jordan-decomposition-note"></a></p>
<h2 id="toc95"><span><a href="computer-algebra2#jordan-decomposition">jordan decomposition</a></span></h2>
<p>The Jordan decomposition of a square matrix <em>A</em> is a factorization <em>A = P ⋅ J ⋅ P<sup>-1</sup></em> where <em>J</em> is in <em>Jordan canonical form</em>.</p>
<p><a name="polar-decomposition-note" id="polar-decomposition-note"></a></p>
<h2 id="toc96"><span><a href="computer-algebra2#polar-decomposition">polar decomposition</a></span></h2>
<p>A factorization of a square matrix into a unitary matrix <em>U</em> and a positive definite Hermitian matrix <em>P</em>.</p>
<p>All invertible matrices have a polar decomposition.</p>
<p>A unitary matrix corresponds to a linear transformation representing a rotation, reflection, or a combination of the two. It is distance perserving, in that it maps vectors to vectors of the same length. A real valued unitary matrix is called an orthogonal matrix.</p>
<p><a name="combinatorics-note" id="combinatorics-note"></a></p>
<h1 id="toc97"><span><a href="computer-algebra2#combinatorics">Combinatorics</a></span></h1>
<p>Enumerative combinatorics is the study of the size of finite sets. The sets are defined by some property, and we seek a formula for the size of the set so defined.</p>
<p>For some simple examples, let <em>A</em> and <em>B</em> be disjoint sets of size <em>n</em> and <em>m</em> respectively. The size of the union <em>A ∪ B</em> is <em>n + m</em> and the size of the Cartesian product <em>A × B</em> is <em>nm</em>. The size of the power set of <em>A</em> is <em>2<sup>n</sup></em>.</p>
<p><a name="factorial-note" id="factorial-note"></a></p>
<h2 id="toc98"><span><a href="computer-algebra2#factorial">factorial</a></span></h2>
<p>The factorial function <em>n!</em> is the product of the first <em>n</em> positive integers <em>1 × 2 × … × n</em>.</p>
<p>It is also the number of permutations or bijective functions on a set of <em>n</em> elements. It is the number of orderings that can be given to <em>n</em> elements.</p>
<p>See the section on permutations below for how to iterate through all <em>n!</em> permutations on a set of <em>n</em> elements.</p>
<p>As the factorial function grows rapidly with <em>n</em>, it is useful to be aware of this approximation:</p>
<span class="equation-number">(7)</span>
<div class="math-equation" id="equation-7">\begin{align} \ln n! \approx n \ln n - n + \frac{1}{2} \ln 2 \pi n \end{align}</div>
<p><a name="binomial-coefficient-note" id="binomial-coefficient-note"></a></p>
<h2 id="toc99"><span><a href="computer-algebra2#binomial-coefficient">binomial coefficient</a></span></h2>
<p>A binomial coefficient can be computed using the factorial function:</p>
<span class="equation-number">(8)</span>
<div class="math-equation" id="equation-8">\begin{align} {n \choose k} = \frac{n!}{(n-k)! k!} \end{align}</div>
<p>The binomial coefficient appears in the binomial theorem:</p>
<span class="equation-number">(9)</span>
<div class="math-equation" id="equation-9">\begin{align} (x+y)^n = \sum_{k=0}^{n} {n \choose k} x^k y^{n-k} \end{align}</div>
<p>The binomial cofficient <span class="math-inline">${ n \choose k }$</span> is the number of sets of size <em>k</em> which can be drawn from a set of size <em>n</em> without replacement.</p>
<p><a name="multinomial-coefficient-note" id="multinomial-coefficient-note"></a></p>
<h2 id="toc100"><span><a href="computer-algebra2#multinomial-coefficient">multinomial coefficient</a></span></h2>
<p>The multinomial coefficient generalizes the binomial cofficient:</p>
<span class="equation-number">(10)</span>
<div class="math-equation" id="equation-10">\begin{align} {n \choose k_1, \ldots, k_m} = \frac{n!}{(k_1! \cdots k_m!} \end{align}</div>
<p>It appears in the multinomial theorem:</p>
<span class="equation-number">(11)</span>
<div class="math-equation" id="equation-11">\begin{align} (x_1 + \cdots + x_m)^n = \sum_{k_1 + \cdots + k_m = n} {n \choose k_1, \ldots, k_m} \prod_{t=1}^m x_t^{k_t} \end{align}</div>
<p>The multinomial cofficient <span class="math-inline">${ n \choose k_1,ldots,k_m }$</span> is the number of ways to partition a set of <em>n</em> elements into subsets of size <em>k<sub>1</sub></em>, …, <em>k<sub>m</sub></em> where the <em>k<sub>i</sub></em> sum to <em>n</em>.</p>
<p><a name="rising-falling-factorial-note" id="rising-falling-factorial-note"></a></p>
<h2 id="toc101"><span><a href="computer-algebra2#rising-falling-factorial">rising and falling factorial</a></span></h2>
<p><a name="subfactorial-note" id="subfactorial-note"></a></p>
<h2 id="toc102"><span><a href="computer-algebra2#subfactorial">subfactorial</a></span></h2>
<p>A <em>derangement</em> is a permutation on a set of <em>n</em> elements where every element moves to a new location.</p>
<p>The number of derangements is thus less than the number of permutations, <em>n!</em>, and the function for the number of derangements is called the <em>subfactorial</em> function.</p>
<p>Using a exclamation point as a prefix to denote the subfactorial, the following equations hold:</p>
<span class="equation-number">(12)</span>
<div class="math-equation" id="equation-12">\begin{align} !n = n \cdot [!(n-1)] + (-1)^n \end{align}</div>
<span class="equation-number">(13)</span>
<div class="math-equation" id="equation-13">\begin{align} !n = n! \sum_{i=0}^n \frac{(-1)^i}{i!} \end{align}</div>
<span class="equation-number">(14)</span>
<div class="math-equation" id="equation-14">\begin{align} lim_{n \rightarrow \infty} \frac{!n}{n!} = \frac{1}{e} \end{align}</div>
<p><a name="int-partitions-note" id="int-partitions-note"></a></p>
<h2 id="toc103"><span><a href="computer-algebra2#int-partitions">integer partitions</a></span></h2>
<p>The number of multisets of positive integers which sum to a integer.</p>
<p>There are 5 integer partitions of 4:</p>
<div class="code">
<pre>
<code>    4
    3 + 1
    2 + 2
    2 + 1 + 1
    1 + 1 + 1 + 1</code>
</pre></div>
<p><a name="compositions-note" id="compositions-note"></a></p>
<h2 id="toc104"><span><a href="computer-algebra2#compositions">compositions</a></span></h2>
<p>The number of sequences of positive integers which sum to an integer.</p>
<p>There are 8 compositions of 4:</p>
<div class="code">
<pre>
<code>    4
    3 + 1
    1 + 3
    2 + 2
    2 + 1 + 1
    1 + 2 + 1
    1 + 1 + 2
    1 + 1 + 1 + 1</code>
</pre></div>
<p><strong>mathematica:</strong></p>
<p>The <tt>NumberOfCompositions</tt> and <tt>Compositions</tt> functions use <em>weak compositions</em>, which include zero as a possible summation.</p>
<p>The number of weak compositions of an integer is infinite, since there is no limit on the number of times zero can appear as a summand. The number of weak compositions of a fixed size is finite, however.</p>
<p><a name="set-partitions-note" id="set-partitions-note"></a></p>
<h2 id="toc105"><span><a href="computer-algebra2#set-partitions">set partitions</a></span></h2>
<p><a name="bell-num-note" id="bell-num-note"></a></p>
<h2 id="toc106"><span><a href="computer-algebra2#set-bell-num">bell number</a></span></h2>
<p><a name="permutations-k-disjoint-cycles-note" id="permutations-k-disjoint-cycles-note"></a></p>
<h2 id="toc107"><span><a href="computer-algebra2#permutations-k-disjoint-cycles">permutations with k disjoint cycles</a></span></h2>
<p><a name="fibonacci-num-note" id="fibonacci-num-note"></a></p>
<h2 id="toc108"><span><a href="computer-algebra2#fibonacci-num">fibonacci number</a></span></h2>
<p><a name="bernoulli-num-note" id="bernoulli-num-note"></a></p>
<h2 id="toc109"><span><a href="computer-algebra2#bernoulli-num">bernoulli number</a></span></h2>
<p><a name="harmonic-num-note" id="harmonic-num-note"></a></p>
<h2 id="toc110"><span><a href="computer-algebra2#harmonic-num">harmonic number</a></span></h2>
<p><a name="catalan-num-note" id="catalan-num-note"></a></p>
<h2 id="toc111"><span><a href="computer-algebra2#catalan-num">catalan number</a></span></h2>
<p><a name="number-theory-note" id="number-theory-note"></a></p>
<h1 id="toc112"><span><a href="computer-algebra2#number-theory">Number Theory</a></span></h1>
<p><a name="divisible-test-note" id="divisible-test-note"></a></p>
<h2 id="toc113"><span><a href="computer-algebra2#divisible-test">divisible test</a></span></h2>
<p>A test whether an integer <em>a</em> is divisible by another integer <em>b</em>.</p>
<p>Equivalently, does there exists a third integer <em>m</em> such that <em>a = mb</em>.</p>
<p><a name="divisors-note" id="divisors-note"></a></p>
<h2 id="toc114"><span><a href="computer-algebra2#divisors">divisors</a></span></h2>
<p>The list of divisors for an integer.</p>
<p><a name="pseudoprime-test-note" id="pseudoprime-test-note"></a></p>
<h2 id="toc115"><span><a href="computer-algebra2#pseudoprime-test">pseudoprime test</a></span></h2>
<p>A fast primality test.</p>
<p>An integer <em>p</em> is prime if for any factorization <em>p = ab</em>, where <em>a</em> and <em>b</em> are integers, either <em>a</em> or <em>b</em> are in the set {-1, 1}.</p>
<p>A number of primality tests exists which give occasional false positives. The simplest of these use Fermat's Little Theorem, in which for prime <em>p</em> and <em>a</em> in <span class="math-inline">$\{1, ..., p - 1\}$</span>:</p>
<span class="equation-number">(15)</span>
<div class="math-equation" id="equation-15">\begin{align} a^{p-1} \equiv 1 \;(\text{mod}\; p) \end{align}</div>
<p>The test for a candidate prime <em>p</em> is to randomly choose several values for <em>a</em> in <span class="math-inline">$\{1, ..., p - 1\}$</span> and evaluate</p>
<span class="equation-number">(16)</span>
<div class="math-equation" id="equation-16">\begin{align} a^{p-1} \;(\text{mod}\; p) \end{align}</div>
<p>If any of them are not equivalent to 1, then the test shows that p is not prime. Unfortunately, there are composite numbers <em>n</em>, the <a href="https://oeis.org/A002997">Carmichael numbers</a>, for which</p>
<span class="equation-number">(17)</span>
<div class="math-equation" id="equation-17">\begin{align} a^{n-1} \equiv 1 \;(\text{mod}\; n) \end{align}</div>
<p>holds for all <em>a</em> in <span class="math-inline">$\{1, ..., n - 1\}$</span>.</p>
<p>A stronger test is the Miller-Rabin primality test. Given a candidate prime <em>n</em>, we factor <em>n - 1</em> as 2<sup>r</sup> ⋅ <em>d</em> where <em>d</em> is odd. If <em>n</em> is prime, then one of the following must be true:</p>
<span class="equation-number">(18)</span>
<div class="math-equation" id="equation-18">\begin{align} a^d \equiv 1 \;(\text{mod}\;n) \end{align}</div>
<span class="equation-number">(19)</span>
<div class="math-equation" id="equation-19">\begin{align} a^{2^r \cdot d} \equiv -1 \;(\text{mod}\;n) \end{align}</div>
<p>Thus, one checks the above two equations for a small number of primes. If we use all primes p ≤ 41, then it is known that there are no false positives for n ≤ 3 × 10<sup>24</sup>.</p>
<p>Since pseuodoprime tests are known which are correct for all integers up to a very large size, and since conclusively showing that a number is prime is a slow operation for larger integers, a true prime test is often not practical.</p>
<p><a name="prime-factors-note" id="prime-factors-note"></a></p>
<h2 id="toc116"><span><a href="computer-algebra2#prime-factors">prime factors</a></span></h2>
<p>The list of prime factors for an integer, with their multiplicities.</p>
<p><a name="next-prime-note" id="next-prime-note"></a></p>
<h2 id="toc117"><span><a href="computer-algebra2#next-prime">next prime</a></span></h2>
<p>The smallest prime number greater than an integer. Also the greatest prime number smaller than an integer.</p>
<p><a name="nth-prime-note" id="nth-prime-note"></a></p>
<h2 id="toc118"><span><a href="computer-algebra2#nth-prime">nth prime</a></span></h2>
<p>The n-th prime number.</p>
<p><a name="prime-counting-func-note" id="prime-counting-func-note"></a></p>
<h2 id="toc119"><span><a href="computer-algebra2#prime-counting-func">prime counting function</a></span></h2>
<p>The number of primes less than or equal to a value.</p>
<p>According to the prime number theorem:</p>
<span class="equation-number">(20)</span>
<div class="math-equation" id="equation-20">\begin{align} \lim_{n \rightarrow \infty} \frac{\pi(n)}{n/\log n} = 1 \end{align}</div>
<p><a name="divmod-note" id="divmod-note"></a></p>
<h2 id="toc120"><span><a href="computer-algebra2#divmod">divmod</a></span></h2>
<p>The quotient and remainder.</p>
<p>If the divisor is positive, then the remainder is non-negative.</p>
<p><a name="gcd-note" id="gcd-note"></a></p>
<h2 id="toc121"><span><a href="computer-algebra2#gcd">greatest common divisor</a></span></h2>
<p>The greatest common divisor of a pair of integers. The divisor is always positive.</p>
<p>Two integers are relatively prime if their greatest common divisor is one.</p>
<p><a name="extended-euclidean-algorithm-note" id="extended-euclidean-algorithm-note"></a></p>
<h2 id="toc122"><span><a href="computer-algebra2#extended-euclidean-algorithm">extended euclidean algorithm</a></span></h2>
<p>How to express a greatest common divisor as a linear combination of the integers it is a GCD of.</p>
<p>The functions described return the GCD in addition to the coefficients.</p>
<p><a name="lcm-note" id="lcm-note"></a></p>
<h2 id="toc123"><span><a href="computer-algebra2#lcm">least common multiple</a></span></h2>
<p>The least common multiple of a pair of integers.</p>
<p>The LCM can be calculated from the GCD using this formula:</p>
<span class="equation-number">(21)</span>
<div class="math-equation" id="equation-21">\begin{align} \text{lcm}(m, n) = \frac{|m\cdot n|}{\text{gcd}(m, n)} \end{align}</div>
<p><a name="power-mod-note" id="power-mod-note"></a></p>
<h2 id="toc124"><span><a href="computer-algebra2#power-mod">power modulus</a></span></h2>
<p>Raise an integer to a integer power, modulo a third integer.</p>
<p>Euler's theorem can often be used to reduce the size of the exponent.</p>
<p><a name="int-residues-note" id="int-residues-note"></a></p>
<h2 id="toc125"><span><a href="computer-algebra2#int-residues">integer residues</a></span></h2>
<p>The integer residues or integers modulo <em>n</em> are the equivalence classes formed by the relation</p>
<span class="equation-number">(22)</span>
<div class="math-equation" id="equation-22">\begin{align} a\;(\text{mod}\;n) = b\; (\text{mod}\;n) \end{align}</div>
<p>An element in of these equivalence classes is called a representative. We can extend addition and multiplication to the residues by performing integer addition or multiplication on representatives. This is well-defined in the sense that it does not depend on the representatives chosen. Addition and multiplication defined this way turn the integer residues into commutative rings with identity.</p>
<p><a name="mult-inverse-note" id="mult-inverse-note"></a></p>
<h2 id="toc126"><span><a href="computer-algebra2#mult-inverse">multiplicative inverse</a></span></h2>
<p>How to get the multiplicative inverse for a residue.</p>
<p>If the representative for a residue is relatively prime to the modulus, then the residue has a multiplicative inverse. For that matter, if the modulus <em>n</em> is a prime, then the ring of residues is a field.</p>
<p>Note that we cannot in general find the inverse using a representative, since the only units in the integers are -1 and 1.</p>
<p>By Euler's theorem, we can find a multiplicative inverse by raising it to the power <span class="math-inline">$\phi(n) - 1$</span>:</p>
<span class="equation-number">(23)</span>
<div class="math-equation" id="equation-23">\begin{align} a^{\phi(n) - 1} \cdot a = a^{\phi(n)} \equiv 1 \;(\text{mod}\;n) \end{align}</div>
<p>When <em>a</em> doesn't have a multiplicative inverse, then we cannot cancel it from both sides of a congruence. The following is true, however:</p>
<span class="equation-number">(24)</span>
<div class="math-equation" id="equation-24">\begin{align} az \equiv az' \;(\text{mod}\; n) \iff z \equiv z' \;\left(\text{mod}\; \frac{n}{\text{gcd}(a, n)}\right) \end{align}</div>
<p><a name="chinese-remainder-thm-note" id="chinese-remainder-thm-note"></a></p>
<h2 id="toc127"><span><a href="computer-algebra2#chinese-remainder-thm">chinese remainder theorem</a></span></h2>
<p>A function which finds a solution to a system of congruences.</p>
<p>The Chinese remainder theorem asserts that there is a solution <em>x</em> to the system of <em>k</em> congruences</p>
<span class="equation-number">(25)</span>
<div class="math-equation" id="equation-25">\begin{align} x \equiv a_i \;(\text{mod}\;n_i) \end{align}</div>
<p>provided that the <em>n<sub>i</sub></em> are pairwise relatively prime. In this case there are an infinite number of solutions, all which are equal modulo <span class="math-inline">$N = n_1 \cdots n_k$</span>. For this reason the solution is returned as a residue modulo <em>N</em>.</p>
<p><a name="lift-int-residue-note" id="lift-int-residue-note"></a></p>
<h2 id="toc128"><span><a href="computer-algebra2#lift-int-residue">lift integer residue</a></span></h2>
<p>How to get a representative from the equivalence class of integers modulo <em>n</em>.</p>
<p>Typically an integer in <span class="math-inline">$\{0, ..., n - 1\}$</span> is chosen. A centered lift chooses a representative <em>x</em> such that <span class="math-inline">$-n/2 &lt; x \leq n/2$</span>.</p>
<p><a name="euler-totient-note" id="euler-totient-note"></a></p>
<h2 id="toc129"><span><a href="computer-algebra2#euler-totient">euler totient</a></span></h2>
<p>The Euler totient function is defined for any positive integer <em>n</em> as:</p>
<span class="equation-number">(26)</span>
<div class="math-equation" id="equation-26">\begin{align} \phi(n) = n \prod_{p | n} \frac{p - 1}{p} \end{align}</div>
<p>Note that the product is over the primes that divide <em>n</em>.</p>
<p>The Euler totient is the number of integers in <span class="math-inline">$\{1, ..., n - 1\}$</span> which are relatively prime to <em>n</em>. It is thus the size of the multiplicative group of integers modulo <em>n</em>.</p>
<p>The Euler totient appears in Euler's theorem:</p>
<span class="equation-number">(27)</span>
<div class="math-equation" id="equation-27">\begin{align} a^{\phi(n)} \equiv 1 \;(\text{mod}\;n) \end{align}</div>
<p><a name="carmichael-func-note" id="carmichael-func-note"></a></p>
<h2 id="toc130"><span><a href="computer-algebra2#carmichael-func">carmichael function</a></span></h2>
<p>The smallest number <em>k</em> such that <em>a<sup>k</sup> ≡ 1 (</em>mod <em>n)</em> for all residues <em>a</em>.</p>
<p>By Euler's theorem, the Carmichael function λ(n) is less that or equal to the Euler totient function φ(n). The functions are equal when there are primitive roots modulo <em>n</em>.</p>
<p><a name="mult-order-note" id="mult-order-note"></a></p>
<h2 id="toc131"><span><a href="computer-algebra2#mult-order">multiplicative order</a></span></h2>
<p>The multiplicative order of a residue <em>a</em> is the smallest exponent <em>k</em> such that</p>
<span class="equation-number">(28)</span>
<div class="math-equation" id="equation-28">\begin{align} a^k \equiv 1\;(\text{mod}\;n) \end{align}</div>
<p>In older literature, it is sometimes said that <em>a</em> belongs to the exponent <em>k</em> modulo <em>n</em>.</p>
<p><a name="primitive-roots-note" id="primitive-roots-note"></a></p>
<h2 id="toc132"><span><a href="computer-algebra2#primitive-roots">primitive roots</a></span></h2>
<p>A primitive root is a residue module <em>n</em> with multiplicative order <em>φ(n)</em>.</p>
<p>The multiplicative group is not necessarily cyclic, though it is when <em>n</em> is prime. If it is not cyclic, then there are no primitive roots.</p>
<p>Any primitive root is a generator for the multiplicative group, so it can be used to find the other primitive roots.</p>
<p><a name="discrete-log-note" id="discrete-log-note"></a></p>
<h2 id="toc133"><span><a href="computer-algebra2#discrete-log">discrete logarithm</a></span></h2>
<p>For a residue <em>x</em> and a base residue <em>b</em>, find a positive integer such that:</p>
<span class="equation-number">(29)</span>
<div class="math-equation" id="equation-29">\begin{align} b^k \equiv x\;(\text{mod}\; n) \end{align}</div>
<p><a name="quadratic-residues-note" id="quadratic-residues-note"></a></p>
<h2 id="toc134"><span><a href="computer-algebra2#quadratic-residues">quadratic residues</a></span></h2>
<p>A quadratic residue is a non-zero residue <em>a</em> which has a square root modulo <em>p</em>. That is, there is <em>x</em> such that</p>
<span class="equation-number">(30)</span>
<div class="math-equation" id="equation-30">\begin{align} x^2 \equiv a \;(\text{mod}\;p) \end{align}</div>
<p>If <em>a</em> is non-zero and doesn't have a square root, then it is a quadratic non-residue.</p>
<p><a name="discrete-sqrt-note" id="discrete-sqrt-note"></a></p>
<h2 id="toc135"><span><a href="computer-algebra2#discrete-sqrt">discrete square root</a></span></h2>
<p>How to find the square root of a quadratic residue.</p>
<p><a name="kronecker-symbol-note" id="kronecker-symbol-note"></a></p>
<h2 id="toc136"><span><a href="computer-algebra2#kronecker-symbol">kronecker symbol</a></span></h2>
<p>The Legendre symbol is used to indicate whether a number is a quadratic residue and is defined as follows:</p>
<span class="equation-number">(31)</span>
<div class="math-equation" id="equation-31">\begin{align} \left( \frac{a}{p} \right) = \begin{cases} \;\; 1 \;\;\; a \; \text{is a quadratic residue} \\ \;\; 0 \;\;\; p \mid a \\ -1 \;\;\; a \; \text{is a quadratic nonresidue} \end{cases} \end{align}</div>
<p>The Legendre symbol is only defined when <em>p</em> is an odd prime, but if <em>n</em> is an odd positive integer with prime factorization</p>
<span class="equation-number">(32)</span>
<div class="math-equation" id="equation-32">\begin{align} p_1^{\alpha_1} \ldots p_n^{\alpha_n} \end{align}</div>
<p>then the Jacobi symbol is defined as</p>
<span class="equation-number">(33)</span>
<div class="math-equation" id="equation-33">\begin{align} \left( \frac{a}{n} \right) = \left( \frac{a}{p_1} \right)^{\alpha_1} \ldots \left( \frac{a}{p_n} \right)^{\alpha_n} \end{align}</div>
<p>The Kronecker symbol is a generalization of the Jacobi symbol to all integers, but we omit the details.</p>
<p><a name="moebius-func-note" id="moebius-func-note"></a></p>
<h2 id="toc137"><span><a href="computer-algebra2#moebius-func">moebius function</a></span></h2>
<p>The Möbius function <em>μ(n)</em> is 1, -1, or 0 depending upon when <em>n</em> is a square-free integer with an even number of prime factors, a square-free integer with an odd number of prime factors, or an integer which is divisible by <em>p<sup>2</sup></em> for some prime <em>p</em>.</p>
<p>The Möbius function is multiplicative: when <em>a</em> and <em>b</em> are relatively prime, <em>μ(a)μ(b) = μ(ab)</em>.</p>
<p>The Möbius function appears in the Möbius inversion formula. If <em>g</em> and <em>f</em> are possibly complex-valued functions defined on the natural numbers such that for all integers n ≥ 1:</p>
<span class="equation-number">(34)</span>
<div class="math-equation" id="equation-34">\begin{align} g(n) = \sum_{d | n} f(d) \end{align}</div>
<p>then for all integers n ≥ 1:</p>
<span class="equation-number">(35)</span>
<div class="math-equation" id="equation-35">\begin{align} f(n) = \sum_{d | n} \mu(d) g(n | d) \end{align}</div>
<p><a name="riemann-zeta-func-note" id="riemann-zeta-func-note"></a></p>
<h2 id="toc138"><span><a href="computer-algebra2#riemann-zeta-func">riemann zeta function</a></span></h2>
<p>The Riemann zeta function is a complex-valued function defined as the analytic continuation of this series:</p>
<span class="equation-number">(36)</span>
<div class="math-equation" id="equation-36">\begin{align} \zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s} \end{align}</div>
<p>The function has zeros (called the trivial zeros) at -2, -4, …. All other zeros must lie in the strip 0 ≤ ℜ(z) ≤ 1. In 1859 Riemann conjectured that all non-trivial zeros are on the line ℜ(z) = 1/2.</p>
<p><a name="continued-fraction-note" id="continued-fraction-note"></a></p>
<h2 id="toc139"><span><a href="computer-algebra2#continued-fraction">continued fraction</a></span></h2>
<p>Convert a real number to a continued fraction.</p>
<p>A continued fraction is a sequence of integers <em>a<sub>0</sub>, a<sub>1</sub>, …, a<sub>n</sub></em> representing the fraction:</p>
<span class="equation-number">(37)</span>
<div class="math-equation" id="equation-37">\begin{align} a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \frac{1}{\ddots + {\frac{1}{a_n}}}}} \end{align}</div>
<p>The sequence can even be infinite, in which case the fraction is the limit of the rational numbers defined by taking the first <em>n</em> digits in the sequence.</p>
<p>A continued fraction for a real number can be computed using the Euclidean algorithm. In the case of a rational number, one starts with the numerator and the denominator. In the case of a rational number, one can start with the number itself and 1.</p>
<p>A continued fraction is finite if and only if the number is a rational.</p>
<p>A continued fraction repeats if and only if it is a quadratic irrational.</p>
<p><a name="convergents-note" id="convergents-note"></a></p>
<h2 id="toc140"><span><a href="computer-algebra2#convergents">convergents</a></span></h2>
<p>The first <em>n</em> digits of a continued fraction define a sequence of rational numbers called the <em>convergents</em>. The rational numbers converge to the number defined by the continued fraction.</p>
<p>Each convergent <em>r/q</em> is the closest rational number to the continued fraction with denominator of size <em>q</em> or smaller.</p>
<p><a name="polynomials-note" id="polynomials-note"></a></p>
<h1 id="toc141"><span><a href="computer-algebra2#polynomials">Polynomials</a></span></h1>
<p><a name="polynomial-literal-note" id="polynomial-literal-note"></a></p>
<h2 id="toc142"><span><a href="computer-algebra2#polynomial-literal">literal</a></span></h2>
<p><a name="extract-polynomial-coefficient-note" id="extract-polynomial-coefficient-note"></a></p>
<h2 id="toc143"><span><a href="computer-algebra2#extract-polynomial-coefficient">extract coefficient</a></span></h2>
<p><a name="extract-polynomial-coefficients-note" id="extract-polynomial-coefficients-note"></a></p>
<h2 id="toc144"><span><a href="computer-algebra2#extract-polynomial-coefficients">extract coefficients</a></span></h2>
<p><a name="polynomial-from-coefficient-array-note" id="polynomial-from-coefficient-array-note"></a></p>
<h2 id="toc145"><span><a href="computer-algebra2#polynomial-from-coefficient-array">from array of coefficients</a></span></h2>
<p><a name="polynomial-degree-note" id="polynomial-degree-note"></a></p>
<h2 id="toc146"><span><a href="computer-algebra2#polynomial-degree">degree</a></span></h2>
<p><a name="expand-polynomial-note" id="expand-polynomial-note"></a></p>
<h2 id="toc147"><span><a href="computer-algebra2#expand-polynomial">expand</a></span></h2>
<p><a name="factor-polynomial-note" id="factor-polynomial-note"></a></p>
<h2 id="toc148"><span><a href="computer-algebra2#factor-polynomial">factor</a></span></h2>
<p>[[ #collect-terms-note]]</p>
<h2 id="toc149"><span><a href="computer-algebra2#collect-terms">collect terms</a></span></h2>
<p><a name="polynomial-roots-note" id="polynomial-roots-note"></a></p>
<h2 id="toc150"><span><a href="computer-algebra2#polynomial-root">roots</a></span></h2>
<p><a name="polynomial-quotient-remainder-note" id="polynomial-quotient-remainder-note"></a></p>
<h2 id="toc151"><span><a href="computer-algebra2#polynomial-quotient-remainder">quotient and remainder</a></span></h2>
<p><a name="polynomial-gcd-note" id="polynomial-gcd-note"></a></p>
<h2 id="toc152"><span><a href="computer-algebra2#polynomial-gcd">greatest common divisor</a></span></h2>
<h2 id="toc153"><span>extended euclidean algorithm</span></h2>
<h2 id="toc154"><span>resultant</span></h2>
<h2 id="toc155"><span>discriminant</span></h2>
<h2 id="toc156"><span>groebner basis</span></h2>
<h2 id="toc157"><span>specify ordering</span></h2>
<h2 id="toc158"><span>elementary symmetric polynomial</span></h2>
<h2 id="toc159"><span>symmetric reduction</span></h2>
<p><a name="cyclotomic-polynomial-note" id="cyclotomic-polynomial-note"></a></p>
<h2 id="toc160"><span><a href="computer-algebra2#cyclotomic-polynomial">cyclotomic polynomial</a></span></h2>
<p><a name="hermite-polynomial-note" id="hermite-polynomial-note"></a></p>
<h2 id="toc161"><span><a href="computer-algebra2#hermite-polynomial">hermite polynomial</a></span></h2>
<p><a name="chebyshev-polynomial-note" id="chebyshev-polynomial-note"></a></p>
<h2 id="toc162"><span><a href="computer-algebra2#chebyshev-polynomial">chebyshev polynomial</a></span></h2>
<h2 id="toc163"><span>interpolation polynomial</span></h2>
<h2 id="toc164"><span>spline</span></h2>
<p><a name="add-fractions-note" id="add-fractions-note"></a></p>
<h2 id="toc165"><span><a href="computer-algebra2#add-fractions">add fractions</a></span></h2>
<p><a name="partial-fraction-decomposition-note" id="partial-fraction-decomposition-note"></a></p>
<h2 id="toc166"><span><a href="computer-algebra2#parial-fraction-decomposition">partial fraction decomposition</a></span></h2>
<p><a name="pade-approximant-note" id="pade-approximant-note"></a></p>
<h2 id="toc167"><span><a href="computer-algebra2#pade-approximant">pade approximant</a></span></h2>
<p><a name="trigonometry-note" id="trigonometry-note"></a></p>
<h1 id="toc168"><span><a href="computer-algebra2#trigonometry">Trigonometry</a></span></h1>
<p><a name="trig-eliminate-powers-products-note" id="trig-eliminate-powers-products-note"></a></p>
<h2 id="toc169"><span><a href="computer-algebra2#trig-eliminate-powers-products">eliminate powers and products of trigonometric functions</a></span></h2>
<p><a name="trig-eliminate-sums-multiples-note" id="trig-eliminate-sums-multiples-note"></a></p>
<h2 id="toc170"><span><a href="computer-algebra2#trig-eliminate-sums-multiples">eliminate sums and multiples inside trigonometric functions</a></span></h2>
<p><a name="trig-to-exp-note" id="trig-to-exp-note"></a></p>
<h2 id="toc171"><span><a href="computer-algebra2#trig-to-exp">trigonometric to exponential</a></span></h2>
<p><a name="exp-to-trig-note" id="exp-to-trig-note"></a></p>
<h2 id="toc172"><span><a href="computer-algebra2#exp-to-trig">exponential to trigonometric</a></span></h2>
<p><a name="fourier-expansion-note" id="fourier-expansion-note"></a></p>
<h2 id="toc173"><span><a href="computer-algebra2#fourier-expansion">fourier expansion</a></span></h2>
<p><a name="periodic-func-note" id="periodic-func-note"></a></p>
<h2 id="toc174"><span><a href="computer-algebra2#periodic-func">periodic functions on unit interval</a></span></h2>
<p><a name="fourier-transform-note" id="fourier-transform-note"></a></p>
<h2 id="toc175"><span><a href="computer-algebra2#fourier-transform">fourier transform</a></span></h2>
<p><a name="heaviside-step-func-note" id="heaviside-step-func-note"></a></p>
<h2 id="toc176"><span><a href="computer-algebra2#heaviside-step-func">heaviside step function</a></span></h2>
<p><a name="dirac-delta-note" id="dirac-delta-note"></a></p>
<h2 id="toc177"><span><a href="computer-algebra2#dirac-delta">dirac delta</a></span></h2>
<p><a name="special-functions-note" id="special-functions-note"></a></p>
<h1 id="toc178"><span><a href="computer-algebra2#special-functions">Special Functions</a></span></h1>
<p><a name="gamma-func-note" id="gamma-func-note"></a></p>
<h2 id="toc179"><span><a href="computer-algebra2#gamma-func">gamma function</a></span></h2>
<p>The gamma function is defined for all complex numbers except the non-positive integers.</p>
<p>For positive integers, the following equation holds:</p>
<span class="equation-number">(38)</span>
<div class="math-equation" id="equation-38">\begin{align} \Gamma(n) = (n-1)! \end{align}</div>
<p>If the real part of <em>t</em> is positive, then</p>
<span class="equation-number">(39)</span>
<div class="math-equation" id="equation-39">\begin{align} \Gamma(t) = \int_0^\infty x^{t-1} e^{-x} dx \end{align}</div>
<p><a name="err-func-note" id="err-func-note"></a></p>
<h2 id="toc180"><span><a href="computer-algebra2#err-func">error function</a></span></h2>
<p>The error function is function from ℝ to [-1, 1] defined by:</p>
<span class="equation-number">(40)</span>
<div class="math-equation" id="equation-40">\begin{align} \mathrm{erf}(x) = \frac{2}{\sqrt(\pi)} \int_0^x e^{-t^2} dt \end{align}</div>
<p>The complementary error function is</p>
<span class="equation-number">(41)</span>
<div class="math-equation" id="equation-41">\begin{align} \mathrm{erfc}(x) = 1 - erf(x) \end{align}</div>
<p>The cumulative distribution of the standard normal distribution is related to the error function by scaling:</p>
<span class="equation-number">(42)</span>
<div class="math-equation" id="equation-42">\begin{align} \Phi(x) = \frac{1}{2} + \frac{1}{2} \mathrm{erf}(\frac{x}{\sqrt(2)}) = \frac{1}{2} \mathrm{erfc}(\frac{-x}{\sqrt(2)}) \end{align}</div>
<p><a name="hyperbolic-func-note" id="hyperbolic-func-note"></a></p>
<h2 id="toc181"><span><a href="computer-algebra2#hyperbolic-func">hyperbolic functions</a></span></h2>
<p>Definitions of the hyperbolic functions:</p>
<span class="equation-number">(43)</span>
<div class="math-equation" id="equation-43">\begin{align} \mathrm{sinh}\;x = \frac{e^x - e^{-x}}{2} \end{align}</div>
<span class="equation-number">(44)</span>
<div class="math-equation" id="equation-44">\begin{align} \mathrm{cosh}\;x = \frac{e^x + e^{-x}}{2} \end{align}</div>
<span class="equation-number">(45)</span>
<div class="math-equation" id="equation-45">\begin{align} \mathrm{tanh}\;x = \frac{\mathrm{sinh}\;x}{\mathrm{cosh}\;x} \end{align}</div>
<p><tt>sinh</tt> and <tt>cosh</tt> are odd and even functions, respectively. Like e<sup>x</sup> and e<sup>-x</sup>, <tt>sinh</tt> and <tt>cosh</tt> span the linear space of solutions to <tt>y''(x) = y(x)</tt>.</p>
<p><a name="elliptic-func-note" id="elliptic-func-note"></a></p>
<h2 id="toc182"><span><a href="computer-algebra2#elliptic-func">elliptic functions</a></span></h2>
<p><a name="bessel-func-note" id="bessel-func-note"></a></p>
<h2 id="toc183"><span><a href="computer-algebra2#bessel-func">bessel functions</a></span></h2>
<p><a name="permutations-note" id="permutations-note"></a></p>
<h1 id="toc184"><span><a href="computer-algebra2#permutations">Permutations</a></span></h1>
<p>A permutation is a bijection on a set of <em>n</em> elements.</p>
<p>The notation that Mathematica uses assumes the set the permutation operates on is indexed by {1, .., n}. The notation that SymPy uses assumes the set is indexed by {0, …, n - 1}.</p>
<p><em>Cayley two line notation</em></p>
<p><em>one line notation</em></p>
<p><em>cycle notation</em></p>
<p><em>inversions</em></p>
<p><a name="permutation-from-disjoint-cycles-note" id="permutation-from-disjoint-cycles-note"></a></p>
<h2 id="toc185"><span><a href="computer-algebra2#permutation-from-disjoint-cycles">from disjoint cycles</a></span></h2>
<p><a name="permutation-to-disjoint-cycles-note" id="permutation-to-disjoint-cycles-note"></a></p>
<h2 id="toc186"><span><a href="computer-algebra2#permutation-to-disjoint-cycles">to disjoint cycles</a></span></h2>
<p><a name="permutation-from-array-note" id="permutation-from-array-note"></a></p>
<h2 id="toc187"><span><a href="computer-algebra2#permutation-from-array">from array</a></span></h2>
<p><a name="permutation-from-two-arrays-note" id="permutation-from-two-arrays-note"></a></p>
<h2 id="toc188"><span><a href="computer-algebra2#permutation-from-two-arrays">from two arrays with same elements</a></span></h2>
<p><a name="permutation-size-note" id="permutation-size-note"></a></p>
<h2 id="toc189"><span><a href="computer-algebra2#permutation-size">size</a></span></h2>
<p><a name="permutation-support-note" id="permutation-support-note"></a></p>
<h2 id="toc190"><span><a href="computer-algebra2#permutation-support">support</a></span></h2>
<p><a name="permutation-act-on-element-note" id="permutation-act-on-element-note"></a></p>
<h2 id="toc191"><span><a href="computer-algebra2#permutation-act-on-element">act on element</a></span></h2>
<p><a name="permutation-act-on-list-note" id="permutation-act-on-list-note"></a></p>
<h2 id="toc192"><span><a href="computer-algebra2#permutation-act-on-list">act on list</a></span></h2>
<p><a name="permutation-compose-note" id="permutation-compose-note"></a></p>
<h2 id="toc193"><span><a href="computer-algebra2#permutation-compose">compose</a></span></h2>
<p><a name="permutation-inverse-note" id="permutation-inverse-note"></a></p>
<h2 id="toc194"><span><a href="computer-algebra2#permutation-inverse">inverse</a></span></h2>
<p><a name="permutation-power-note" id="permutation-power-note"></a></p>
<h2 id="toc195"><span><a href="computer-algebra2#permutation-power">power</a></span></h2>
<p><a name="permutation-order-note" id="permutation-order-note"></a></p>
<h2 id="toc196"><span><a href="computer-algebra2#permutation-order">order</a></span></h2>
<p><a name="permutation-num-inversions-note" id="permutation-num-inversions-note"></a></p>
<h2 id="toc197"><span><a href="computer-algebra2#permutation-num-inversions">number of inversions</a></span></h2>
<p><a name="permutation-parity-note" id="permutation-parity-note"></a></p>
<h2 id="toc198"><span><a href="computer-algebra2#permutation-parity">parity</a></span></h2>
<p>Permutations are classified as even or odd based on the number of inversions.</p>
<p>The composition of two even permutations is even.</p>
<p><a name="permutation-to-inversion-vec-note" id="permutation-to-inversion-vec-note"></a></p>
<h2 id="toc199"><span><a href="computer-algebra2#permutation-to-inversion-vec">to inversion vector</a></span></h2>
<p><a name="permutation-from-inversion-vec-note" id="permutation-from-inversion-vec-note"></a></p>
<h2 id="toc200"><span><a href="computer-algebra2#permutation-from-inversion-vec">from inversion vector</a></span></h2>
<p><a name="permutation-list-note" id="permutation-list-note"></a></p>
<h2 id="toc201"><span><a href="computer-algebra2#permutation-list">list permutations</a></span></h2>
<p><a name="permutation-random-note" id="permutation-random-note"></a></p>
<h2 id="toc202"><span><a href="computer-algebra2#permutation-random">random permutation</a></span></h2>
<p><a name="descriptive-statistics-note" id="descriptive-statistics-note"></a></p>
<h1 id="toc203"><span><a href="computer-algebra2#descriptive-statistics">Descriptive Statistics</a></span></h1>
<p><a name="distributions-note" id="distributions-note"></a></p>
<h1 id="toc204"><span><a href="computer-algebra2#distributions">Distributions</a></span></h1>
<p><a name="statistical-tests-note" id="statistical-tests-note"></a></p>
<h1 id="toc205"><span><a href="computer-algebra2#statistical-tests">Statistical Tests</a></span></h1>
<p>A selection of statistical tests. For each test the null hypothesis of the test is stated in the left column.</p>
<p>In a null hypothesis test one considers the <em>p-value</em>, which is the chance of getting data which is as or more extreme than the observed data if the null hypothesis is true. The null hypothesis is usually a supposition that the data is drawn from a distribution with certain parameters.</p>
<p>The extremeness of the data is determined by comparing the expected value of a parameter according to the null hypothesis to the estimated value from the data. Usually the parameter is a mean or variance. In a <em>one-tailed test</em> the p-value is the chance the difference is greater than the observed amount; in a <em>two-tailed test</em> the p-value is the chance the absolute value of the difference is greater than the observed amount.</p>
<p><a name="wilcoxon-note" id="wilcoxon-note"></a></p>
<h2 id="toc206"><span><a href="computer-algebra2#wilcoxon">wilcoxon signed-rank test</a></span></h2>
<p>A non-parametric est whether a variable is drawn from a distribution that is symmetric about zero.</p>
<p>Often this test is used to test that the mean of the distribution is zero.</p>
<p><a name="kruskal-note" id="kruskal-note"></a></p>
<h2 id="toc207"><span><a href="computer-algebra2#kruskal">kruskal-wallis rank sum test</a></span></h2>
<p>A non-parametric test whether variables have the same mean.</p>
<p>For two variables, this test is the same as the Mann-Whitney test.</p>
<p><strong>maxima:</strong></p>
<p>The Maxima function only supports testing two variables.</p>
<p><a name="kolmogorov-smirnov-test-note" id="kolmogorov-smirnov-test-note"></a></p>
<h2 id="toc208"><span><a href="computer-algebra2#kolmogorov-smirnov-test">kolmogorov-smirnov test</a></span></h2>
<p>Test whether two samples are drawn from the same distribution.</p>
<p><a name="one-sample-t-test-note" id="one-sample-t-test-note"></a></p>
<h2 id="toc209"><span><a href="computer-algebra2#one-sample-t-test">one-sample t-test</a></span></h2>
<p>Student's t-test determines whether a sample drawn from a normal distribution has mean zero.</p>
<p>The test can be used to test for a different mean value; just subtract the value from each value in the sample.</p>
<p>One may know in advance that the sample is drawn from a normal distribution. For example, if the values in the sample are each means of large samples, then the distribution is normal by the central limit theorem.</p>
<p>The Shapiro-Wilk test can be applied to determine if the values come from a normal distribution.</p>
<p>If the distribution is not known to be normal, the Wilcoxon signed-rank test can be used instead.</p>
<p>The Student's t-test used the sample to estimate the variance, and as a result the test statistic has a t-distribution.</p>
<p>By way of contrast, the z-test assumes that the variance is known in advance, and simply scales the data to get a z-score, which has standard normal distribution.</p>
<p><a name="independent-two-sample-t-test-note" id="independent-two-sample-t-test-note"></a></p>
<h2 id="toc210"><span><a href="computer-algebra2#independent-two-sample-t-test">independent two-sample t-test</a></span></h2>
<p>Test whether two normal variables have same mean.</p>
<p><a name="paired-sample-t-test-note" id="paired-sample-t-test-note"></a></p>
<h2 id="toc211"><span><a href="computer-algebra2#paired-t-test">paired sample t-test</a></span></h2>
<p>A t-test used when the same individuals are measure twice.</p>
<p><a name="one-sample-binomial-test-note" id="one-sample-binomial-test-note"></a></p>
<h2 id="toc212"><span><a href="computer-algebra2#one-sample-binomial-test">one-sample binomial test</a></span></h2>
<p><a name="two-sample-binomial-test-note" id="two-sample-binomial-test-note"></a></p>
<h2 id="toc213"><span><a href="computer-algebra2#two-sample-binomial-test">two-sample binomial test</a></span></h2>
<p><a name="chi-squared-test-note" id="chi-squared-test-note"></a></p>
<h2 id="toc214"><span><a href="computer-algebra2#chi-squared-test">chi-squared test</a></span></h2>
<p><a name="poisson-test-note" id="poisson-test-note"></a></p>
<h2 id="toc215"><span><a href="computer-algebra2#poisson-test">poisson test</a></span></h2>
<p><a name="f-test-note" id="f-test-note"></a></p>
<h2 id="toc216"><span><a href="computer-algebra2#f-test">F test</a></span></h2>
<p><a name="pearson-product-moment-test-note" id="pearson-product-moment-test-note"></a></p>
<h2 id="toc217"><span><a href="computer-algebra2#pearson-product-moment-test">pearson product moment test</a></span></h2>
<p><a name="spearman-rank-test-note" id="spearman-rank-test-note"></a></p>
<h2 id="toc218"><span><a href="computer-algebra2#spearman-rank-test">pearson spearman rank test</a></span></h2>
<p><a name="shapiro-wilk-test-note" id="shapiro-wilk-test-note"></a></p>
<h2 id="toc219"><span><a href="computer-algebra2#shapiro-wilk-test">shapiro-wilk test</a></span></h2>
<p><a name="bartletts-test-note" id="bartletts-test-note"></a></p>
<h2 id="toc220"><span><a href="computer-algebra2#bartletts-test">bartlett's test</a></span></h2>
<p>A test whether variables are drawn from normal distributions with the same variance.</p>
<p><a name="levene-test-note" id="levene-test-note"></a></p>
<h2 id="toc221"><span><a href="computer-algebra2#levene-test">levene's test</a></span></h2>
<p>A test whether variables are drawn from distributions with the same variance.</p>
<p><a name="one-way-anova-note" id="one-way-anova-note"></a></p>
<h2 id="toc222"><span><a href="computer-algebra2#one-way-anova">one-way anova</a></span></h2>
<p><a name="two-way-anova-note" id="two-way-anova-note"></a></p>
<h2 id="toc223"><span><a href="computer-algebra2#two-way-anova">two-way anova</a></span></h2>
<p><a name="bar-charts-note" id="bar-charts-note"></a></p>
<h1 id="toc224"><span><a href="computer-algebra2#bar-charts">Bar Charts</a></span></h1>
<p><a name="vertical-bar-chart-note" id="vertical-bar-chart-note"></a></p>
<h2 id="toc225"><span><a href="computer-algebra2#vertical-bar-chart">vertical bar chart</a></span></h2>
<p>A chart in which the height of bars is used to represent a list of numbers.</p>
<p><strong>maxima:</strong></p>
<p>Maxima plots the frequency of the values, and not the values themselves. Non-positive values cannot be represented.</p>
<p><a name="horizontal-bar-chart-note" id="horizontal-bar-chart-note"></a></p>
<h2 id="toc226"><span><a href="computer-algebra2#horizontal-bar-chart">horizontal bar chart</a></span></h2>
<p>A bar chart in which zero is the y-axis and the bars extend to the right.</p>
<p><a name="grouped-bar-chart-note" id="grouped-bar-chart-note"></a></p>
<h2 id="toc227"><span><a href="computer-algebra2#grouped-bar-chart">grouped bar chart</a></span></h2>
<p><a name="stacked-bar-chart-note" id="stacked-bar-chart-note"></a></p>
<h2 id="toc228"><span><a href="computer-algebra2#stacked-bar-chart">stacked bar chart</a></span></h2>
<p><a name="pie-chart-note" id="pie-chart-note"></a></p>
<h2 id="toc229"><span><a href="computer-algebra2#pie-chart">pie chart</a></span></h2>
<p><strong>maxima:</strong></p>
<p>Note that Maxima plots the frequency of the values, and not the values themselves.</p>
<p><a name="histogram-note" id="histogram-note"></a></p>
<h2 id="toc230"><span><a href="computer-algebra2#histogram">histogram</a></span></h2>
<p>A histogram is a bar chart in which each bar represents the frequency of values in a data set within a range. The width of the bars can be used to indicate the ranges.</p>
<p><a name="box-plot-note" id="box-plot-note"></a></p>
<h2 id="toc231"><span><a href="computer-algebra2#box-plot">box plot</a></span></h2>
<p><a name="scatter-plots-note" id="scatter-plots-note"></a></p>
<h1 id="toc232"><span><a href="computer-algebra2#scatter-plots">Scatter Plots</a></span></h1>
<p><a name="strip-chart-note" id="strip-chart-note"></a></p>
<h2 id="toc233"><span><a href="computer-algebra2#strip-chart">strip chart</a></span></h2>
<p>A strip chart represents a list of values by points on a line. The values are converted to pairs by assigning the y-coordinate a constant value of zero. Pairs are then displayed with a scatter plot.</p>
<p><a name="strip-chart-jitter-note" id="strip-chart-jitter-note"></a></p>
<h2 id="toc234"><span><a href="computer-algebra2#strip-chart-jitter">strip chart with jitter</a></span></h2>
<p>A strip chart in which in which a random variable with small range is used to fill the y-coordinate. Jitter makes it easier to see how many values are in dense regions.</p>
<p><a name="scatter-plot-note" id="scatter-plot-note"></a></p>
<h2 id="toc235"><span><a href="computer-algebra2#scatter-plot">scatter plot</a></span></h2>
<p>How to plot a list of pairs of numbers by representing the pairs as points in the (x, y) plane.</p>
<p><a name="additional-point-set-note" id="additional-point-set-note"></a></p>
<h2 id="toc236"><span><a href="computer-algebra2#additional-point-set">additional point set</a></span></h2>
<p>How to add a second list of pairs of numbers to a scatter plot. Color can be used to distinguish the two data sets.</p>
<p><a name="point-types-note" id="point-types-note"></a></p>
<h2 id="toc237"><span><a href="computer-algebra2#point-types">point types</a></span></h2>
<p>How to select the symbols used to mark data points. Choice of symbols can be use to distinguish data sets.</p>
<p><a name="point-size-note" id="point-size-note"></a></p>
<h2 id="toc238"><span><a href="computer-algebra2#point-size">point size</a></span></h2>
<p>How to change the size of the symbols used to mark points.</p>
<p><a name="scatter-plot-matrix-note" id="scatter-plot-matrix-note"></a></p>
<h2 id="toc239"><span><a href="computer-algebra2#scatter-plot-matrix">scatter plot matrix</a></span></h2>
<p>A scatter plot matrix is a way of displaying a multivariate data set by means of a grid of scatter plots. Off-diagonal plots are scatter plots of two of the variables. On-diagonal plots can be used to to display the name or a histogram of one of the variables.</p>
<p><a name="scatter-plot-3d-note" id="scatter-plot-3d-note"></a></p>
<h2 id="toc240"><span><a href="computer-algebra2#scatter-plot-3d">3d scatter plot</a></span></h2>
<p>How to represent a list of triples of numbers by points in (x, y, z) space.</p>
<p><a name="bubble-chart-note" id="bubble-chart-note"></a></p>
<h2 id="toc241"><span><a href="computer-algebra2#bubble-chart">bubble chart</a></span></h2>
<p>How to represent a list of triples of numbers by position in the (x, y) plane and size of the point marker.</p>
<p>It is probably better to associate the 3rd component of each triple with the <em>area</em>, and not the <em>diameter</em> of the point marker, but in general bubble charts suffer from ambiguity.</p>
<p><a name="linear-regression-line-note" id="linear-regression-line-note"></a></p>
<h2 id="toc242"><span><a href="computer-algebra2#linear-regression-line">linear regression line</a></span></h2>
<p>How to add a linear regression line to a scatter plot.</p>
<p><a name="q-q-plot-note" id="q-q-plot-note"></a></p>
<h2 id="toc243"><span><a href="computer-algebra2#q-q-plot">quantile-quantile plot</a></span></h2>
<p><a name="line-charts-note" id="line-charts-note"></a></p>
<h1 id="toc244"><span><a href="computer-algebra2#line-charts">Line Charts</a></span></h1>
<p><a name="polygonal-line-plot-note" id="polygonal-line-plot-note"></a></p>
<h2 id="toc245"><span><a href="computer-algebra2#polygonal-line-plot">polygonal line plot</a></span></h2>
<p><a name="additional-line-note" id="additional-line-note"></a></p>
<h2 id="toc246"><span><a href="computer-algebra2#additional-line">additional line</a></span></h2>
<p><a name="line-types-note" id="line-types-note"></a></p>
<h2 id="toc247"><span><a href="computer-algebra2#line-types">line types</a></span></h2>
<p><a name="line-thickness-note" id="line-thickness-note"></a></p>
<h2 id="toc248"><span><a href="computer-algebra2#line-thickness">line thickness</a></span></h2>
<p><a name="function-plot-note" id="function-plot-note"></a></p>
<h2 id="toc249"><span><a href="computer-algebra2#function-plot">function plot</a></span></h2>
<p><a name="parametric-plot-note" id="parametric-plot-note"></a></p>
<h2 id="toc250"><span><a href="computer-algebra2#parametric-plot">parametric plot</a></span></h2>
<p><a name="implicit-plot-note" id="implicit-plot-note"></a></p>
<h2 id="toc251"><span><a href="computer-algebra2#implicit-plot">implicit plot</a></span></h2>
<p><a name="polar-plot-note" id="polar-plot-note"></a></p>
<h2 id="toc252"><span><a href="computer-algebra2#polar-plot">polar plot</a></span></h2>
<p><a name="cubic-spline-note" id="cubic-spline-note"></a></p>
<h2 id="toc253"><span><a href="computer-algebra2#cubic-spline">cubic spline</a></span></h2>
<p><a name="area-chart-note" id="area-chart-note"></a></p>
<h2 id="toc254"><span><a href="computer-algebra2#area-chart">area chart</a></span></h2>
<p><a name="surface-charts-note" id="surface-charts-note"></a></p>
<h1 id="toc255"><span><a href="computer-algebra2#surface-charts">Surface Charts</a></span></h1>
<p><a name="contour-plot-note" id="contour-plot-note"></a></p>
<h2 id="toc256"><span><a href="computer-algebra2#contour-plot">contour plot</a></span></h2>
<p><a name="heat-map-note" id="heat-map-note"></a></p>
<h2 id="toc257"><span><a href="computer-algebra2#heat-map">heat map</a></span></h2>
<p><a name="shaded-surface-plot-note" id="shaded-surface-plot-note"></a></p>
<h2 id="toc258"><span><a href="computer-algebra2#shaded-surface-plot">shaded surface plot</a></span></h2>
<p><a name="light-source-note" id="light-source-note"></a></p>
<h2 id="toc259"><span><a href="computer-algebra2#light-source">light source</a></span></h2>
<p><a name="mesh-surface-plot-note" id="mesh-surface-plot-note"></a></p>
<h2 id="toc260"><span><a href="computer-algebra2#mesh-surface-plot">mesh surface plot</a></span></h2>
<p><a name="view-point-note" id="view-point-note"></a></p>
<h2 id="toc261"><span><a href="computer-algebra2#view-point">view point</a></span></h2>
<p><a name="vector-field-plot-note" id="vector-field-plot-note"></a></p>
<h2 id="toc262"><span><a href="computer-algebra2#vector-field-plot">vector field plot</a></span></h2>
<p><a name="chart-options-note" id="chart-options-note"></a></p>
<h1 id="toc263"><span><a href="computer-algebra2#chart-options">Chart Options</a></span></h1>
<p><a name="chart-title-note" id="chart-title-note"></a></p>
<h2 id="toc264"><span><a href="computer-algebra2#chart-title">chart title</a></span></h2>
<p><a name="axis-label-note" id="axis-label-note"></a></p>
<h2 id="toc265"><span><a href="computer-algebra2#axis-label">axis label</a></span></h2>
<p><a name="legend-note" id="legend-note"></a></p>
<h2 id="toc266"><span><a href="computer-algebra2#legend">legend</a></span></h2>
<p><a name="data-label-note" id="data-label-note"></a></p>
<h2 id="toc267"><span><a href="computer-algebra2#data-label">data label</a></span></h2>
<p><a name="named-colors-note" id="named-colors-note"></a></p>
<h2 id="toc268"><span><a href="computer-algebra2#named-colors">named colors</a></span></h2>
<p><a name="rgb-color-note" id="rgb-color-note"></a></p>
<h2 id="toc269"><span><a href="computer-algebra2#rgb-color">rgb color</a></span></h2>
<p><a name="background-color-note" id="background-color-note"></a></p>
<h2 id="toc270"><span><a href="computer-algebra2#background-color">background color</a></span></h2>
<p><a name="axis-limits-note" id="axis-limits-note"></a></p>
<h2 id="toc271"><span><a href="computer-algebra2#axis-limits">axis limits</a></span></h2>
<p><a name="logarithmic-y-axis-note" id="logarithmic-y-axis-note"></a></p>
<h2 id="toc272"><span><a href="computer-algebra2#logarithmic-y-axis">logarithmic y-axis</a></span></h2>
<p><a name="aspect-ratio-note" id="aspect-ratio-note"></a></p>
<h2 id="toc273"><span><a href="computer-algebra2#aspect-ratio">aspect ratio</a></span></h2>
<p><a name="ticks-note" id="ticks-note"></a></p>
<h2 id="toc274"><span><a href="computer-algebra2#ticks">ticks</a></span></h2>
<p><a name="grid-lines-note" id="grid-lines-note"></a></p>
<h2 id="toc275"><span><a href="computer-algebra2#grid-lines">grid lines</a></span></h2>
<p><a name="grid-of-subplots-note" id="grid-of-subplots-note"></a></p>
<h2 id="toc276"><span><a href="computer-algebra2#grid-of-subplots">grid of subplots</a></span></h2>
<p><a name="save-plot-as-png-note" id="save-plot-as-png-note"></a></p>
<h2 id="toc277"><span><a href="computer-algebra2#save-plot-as-png">save plot as png</a></span></h2>
<p><a name="mathematica" id="mathematica"></a></p>
<h1 id="toc278"><span><a href="computer-algebra2#top">Mathematica</a></span></h1>
<p><a href="http://reference.wolfram.com/mathematica/guide/Mathematica.html">Mathematica Documentation Center</a><br />
<a href="http://wolframalpha.com">WolframAlpha</a></p>
<p><a name="sympy" id="sympy"></a></p>
<h1 id="toc279"><span><a href="computer-algebra2#top">SymPy</a></span></h1>
<p><a href="http://docs.sympy.org/latest/index.html">Welcome to SymPy’s documentation!</a></p>
<p><a name="sage" id="sage"></a></p>
<h1 id="toc280"><span><a href="computer-algebra2#top">Sage</a></span></h1>
<p><a href="http://doc.sagemath.org/html/en/index.html">http://doc.sagemath.org/html/en/index.html</a></p>
<p><a name="maxima" id="maxima"></a></p>
<h1 id="toc281"><span><a href="computer-algebra2#top">Maxima</a></span></h1>
<p><a href="http://maxima.sourceforge.net/docs/manual/maxima.html">http://maxima.sourceforge.net/docs/manual/maxima.html</a></p>

                    </div>
        </div>
      </div>
      <div id="license-area" class="license-area">
        <a href="https://github.com/clarkgrubb/hyperpolyglot/issues">issue tracker</a> |
        content of this page licensed under
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">
        creative commons attribution-sharealike 3.0</a>
        <br>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17129977-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
